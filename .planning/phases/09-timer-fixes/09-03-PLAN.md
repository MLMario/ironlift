---
phase: 09-timer-fixes
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - app/workout.tsx
autonomous: false

must_haves:
  truths:
    - "Rest timer bar shows exercise rest time immediately when workout starts (before any set completion)"
    - "+/-10s buttons work from the start of the workout (not only after first set completion)"
    - "User can tap time display to edit rest time directly via text input"
    - "Rest time edits persist within the workout session"
    - "On workout finish, changed rest times auto-save silently to template (no confirmation)"
    - "On workout discard/cancel, rest time changes are discarded"
    - "Rest time save is independent from structural change save"
    - "Timer pauses when time text tapped during countdown, restarts from new value on edit confirm"
    - "When structural update is accepted, the updateTemplate payload uses current session-edited rest_seconds values"
  artifacts:
    - path: "app/workout.tsx"
      provides: "Workout screen with full rest time editing and save flow"
  key_links:
    - from: "app/workout.tsx"
      to: "src/hooks/useWorkoutState.ts"
      via: "updateRestSeconds and getRestTimeChanges"
      pattern: "updateRestSeconds|getRestTimeChanges"
    - from: "app/workout.tsx"
      to: "src/hooks/useRestTimer.ts"
      via: "pause method"
      pattern: "pause.*useRestTimer|restTimer.*pause"
    - from: "app/workout.tsx"
      to: "src/services/templates.ts"
      via: "updateTemplateExercise for silent rest time save"
      pattern: "updateTemplateExercise"
    - from: "app/workout.tsx"
      to: "src/components/WorkoutExerciseCard.tsx"
      via: "new timer props (restSeconds, onRestTimeChange, onTimerPause, onTimerRestart)"
      pattern: "restSeconds=|onRestTimeChange=|onTimerPause=|onTimerRestart="
---

<objective>
Wire the workout screen to support rest time editing flow: idle +/-10s buttons, session-scoped rest time changes, timer pause/restart, and silent rest time save on finish.

Purpose: This connects all the foundational hooks and component changes from Plans 01 and 02 to the workout screen, completing the user-facing feature. Also includes human verification of the full timer editing flow.

Output: Modified workout.tsx with complete rest time editing and save flow, verified on device.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-timer-fixes/09-CONTEXT.md
@.planning/phases/09-timer-fixes/09-RESEARCH.md
@.planning/phases/09-timer-fixes/09-01-SUMMARY.md
@.planning/phases/09-timer-fixes/09-02-SUMMARY.md
@app/workout.tsx
@src/hooks/useWorkoutState.ts
@src/hooks/useRestTimer.ts
@src/services/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire workout.tsx with rest time editing and silent save</name>
  <files>app/workout.tsx</files>
  <action>
Modify workout.tsx to wire the new rest time editing capabilities end-to-end.

**1. Destructure new exports from hooks:**

From useWorkoutState, add to destructuring:
```typescript
const {
  // ... existing ...
  updateRestSeconds,
  getRestTimeChanges,
} = useWorkoutState(template, restoredBackup);
```

From useRestTimer, add pause:
```typescript
const {
  // ... existing ...
  pause: pauseTimer,
} = useRestTimer();
```

**2. Create handleRestTimeChange callback:**
```typescript
const handleRestTimeChange = useCallback(
  (exerciseIndex: number, seconds: number) => {
    updateRestSeconds(exerciseIndex, seconds);
    triggerBackup(); // Backup on rest time change (meaningful action)
  },
  [updateRestSeconds, triggerBackup]
);
```

**3. Create handleTimerPause callback:**
```typescript
const handleTimerPause = useCallback(
  () => {
    pauseTimer();
  },
  [pauseTimer]
);
```

**4. Create handleTimerRestart callback:**
```typescript
const handleTimerRestart = useCallback(
  (exerciseIndex: number, seconds: number) => {
    startTimer(exerciseIndex, seconds);
  },
  [startTimer]
);
```

**5. Update handleAdjustTimer to handle idle state:**
Currently handleAdjustTimer just calls `adjustTimer(delta)` which does nothing when timer is idle (timerParamsRef is null). The new RestTimerBar handles this internally -- when not in active countdown, the bar calls `onRestTimeChange` directly instead of `onAdjust`. So no change needed to handleAdjustTimer itself. But verify the flow:
- INACTIVE: RestTimerBar calls onRestTimeChange(clamped) -- goes to handleRestTimeChange
- ACTIVE: RestTimerBar calls onAdjust(delta) + onRestTimeChange(clamped) -- adjust updates running timer, restTimeChange persists
- EDITING: RestTimerBar updates editText locally, confirms on blur

**6. Update getTimerProps to include restSeconds:**
```typescript
function getTimerProps(exerciseIndex: number) {
  const exercise = activeWorkout.exercises[exerciseIndex];
  const restSeconds = exercise.rest_seconds;
  const isActive = isActiveForExercise(exerciseIndex);

  if (isActive && timer.status === 'active') {
    return {
      timerRemaining: timer.remaining,
      timerTotal: timer.duration,
      isTimerActive: true,
      restSeconds,
    };
  }

  return {
    timerRemaining: restSeconds,
    timerTotal: restSeconds,
    isTimerActive: false,
    restSeconds,
  };
}
```

**7. Update WorkoutExerciseCard rendering to pass new props:**
In the .map() where exercise cards are rendered, add the new props:
```tsx
<WorkoutExerciseCard
  key={`${exercise.exercise_id}-${exerciseIndex}`}
  exercise={exercise}
  exerciseIndex={exerciseIndex}
  // ... existing props ...
  timerRemaining={timerProps.timerRemaining}
  timerTotal={timerProps.timerTotal}
  isTimerActive={timerProps.isTimerActive}
  restSeconds={timerProps.restSeconds}
  onAdjustTimer={handleAdjustTimer}
  onRestTimeChange={(seconds) => handleRestTimeChange(exerciseIndex, seconds)}
  onTimerPause={handleTimerPause}
  onTimerRestart={(seconds) => handleTimerRestart(exerciseIndex, seconds)}
  // ... existing swipe props ...
/>
```

**8. Add silent rest time save to finish flow:**

Create a `saveRestTimeChanges` async function (can be defined inside the component or as a standalone helper):
```typescript
async function saveRestTimeChanges(): Promise<void> {
  const changes = getRestTimeChanges();
  if (changes.length === 0) return;
  if (!activeWorkout.template_id) return;

  for (const change of changes) {
    try {
      await templatesService.updateTemplateExercise(
        activeWorkout.template_id,
        change.exercise_id,
        { default_rest_seconds: change.rest_seconds }
      );
    } catch {
      // Best-effort per locked decision -- skip silently on failure
    }
  }
}
```

**9. Integrate rest time save into saveWorkoutAndCleanup:**

Per locked decision: rest time save is INDEPENDENT from structural change save. Per Pitfall 5 from research: if user accepts structural update, rest times are already included in the updateTemplate payload (it uses `ex.rest_seconds` as `default_rest_seconds`). So only run per-exercise rest time save when:
- No structural changes exist, OR
- User declined structural update

Modify `saveWorkoutAndCleanup(shouldUpdateTemplate: boolean)`:
- BEFORE the existing try block (or at the top of the try block), check: if `shouldUpdateTemplate` is false (either no structural changes, or user declined), then call `await saveRestTimeChanges()`.
- If `shouldUpdateTemplate` is true, skip the separate rest time save because the structural update already includes rest times.

**IMPORTANT -- Verify structural update picks up session-edited rest times:**
When `shouldUpdateTemplate` is true, the existing `updateTemplate` call constructs its payload from `activeWorkout.exercises`. Verify that this payload uses `exercise.rest_seconds` (which includes any session edits from `updateRestSeconds`) as the `default_rest_seconds` value. If the existing code already maps `ex.rest_seconds` -> `default_rest_seconds` in the updateTemplate payload, no change is needed. If it uses the original template snapshot values instead, update it to use `activeWorkout.exercises[].rest_seconds`. This ensures that when a user both adds/removes exercises AND edits rest times, the structural update includes the rest time edits.

The logic placement inside saveWorkoutAndCleanup:
```typescript
const saveWorkoutAndCleanup = useCallback(
  async (shouldUpdateTemplate: boolean) => {
    setIsSaving(true);
    // ... existing workoutData construction ...

    try {
      // Silent rest time save (independent from structural changes)
      // Only needed when NOT doing a structural update (which already includes rest times)
      if (!shouldUpdateTemplate) {
        await saveRestTimeChanges();
      }

      // Update template if requested (existing structural change code, unchanged)
      if (shouldUpdateTemplate && activeWorkout.template_id) {
        // ... existing updateTemplate code ...
        // This already uses activeWorkout.exercises which includes session-edited rest_seconds
      }

      // ... rest of existing save logic unchanged ...
    } catch {
      // ... existing error handling unchanged ...
    }
  },
  [activeWorkout, stopTimer, backup, router, getRestTimeChanges]
);
```

Note: `saveRestTimeChanges` uses `getRestTimeChanges()` from the closure. Add `getRestTimeChanges` to the dependency array of `saveWorkoutAndCleanup`.

**10. Cancel flow -- no changes needed:**
On cancel/discard, `handleCancelConfirm` calls `stopTimer()`, `backup.clear()`, and `router.back()`. The rest time changes are only in `activeWorkout` state which gets garbage collected when the component unmounts. No persistence happens. This matches the locked decision: "On workout discard/cancel: rest time changes are discarded, template unchanged."
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npx expo start` and verify the app launches without crash on the workout screen. Verify that the updateTemplate payload (when structural changes exist) uses `activeWorkout.exercises[].rest_seconds` for `default_rest_seconds`, not original snapshot values.
  </verify>
  <done>
Workout screen wires all rest time editing capabilities: idle +/-10s via onRestTimeChange, pause/restart via onTimerPause/onTimerRestart, session-scoped changes via updateRestSeconds, and silent auto-save on finish via saveRestTimeChanges. When structural update is accepted, the updateTemplate payload includes session-edited rest_seconds. Cancel/discard discards all changes. TypeScript compiles cleanly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete rest timer editing feature across the active workout screen:
1. RestTimerBar shows exercise rest time immediately on workout load (before any set completion)
2. +/-10s buttons work from start (not just during countdown)
3. Tapping time text enters edit mode with TextInput (both in idle and during countdown)
4. Blur confirms edit (parseable -> clamp to 10-600s, unparseable -> revert)
5. Timer pauses on edit during countdown, restarts from new value on confirm
6. Rest time changes persist within session and auto-save to template on finish
7. Cancel/discard does NOT save rest time changes
  </what-built>
  <how-to-verify>
Test on device via Expo Go:

1. **Initial visibility test:**
   - Start a workout from a template
   - Verify ALL exercise cards are expanded and show their rest timer bars immediately
   - Verify each bar shows the exercise's configured rest time (e.g., "1:30")

2. **Idle +/-10s test:**
   - Without completing any set, tap the +10s button on any exercise
   - Verify the displayed time increases by 10 seconds
   - Tap -10s and verify it decreases
   - Verify it clamps at 10s minimum (cannot go below 0:10)

3. **Tap-to-edit test (idle):**
   - Tap the time text in the center of the bar
   - Verify a TextInput appears with the current time pre-filled in M:SS format
   - Type "45" (plain seconds) and tap outside the input
   - Verify the bar now shows "0:45"
   - Tap the time again, type "2:00" and tap outside
   - Verify the bar shows "2:00"
   - Tap the time again, type "abc" and tap outside
   - Verify the bar reverts to "2:00" (unparseable -> revert)
   - Tap the time again, clear the field completely and tap outside
   - Verify the bar reverts to "2:00" (empty -> revert)

4. **+/-10s during edit mode test:**
   - Tap the time text to enter edit mode
   - While TextInput is focused, tap +10s
   - Verify the TextInput value updates (e.g., "2:00" -> "2:10")
   - Verify the TextInput remains focused (did not exit edit mode)

5. **Active countdown + edit test:**
   - Complete a set (tap the done checkbox)
   - While the countdown is running, tap the countdown time text
   - Verify the timer pauses and edit mode opens
   - Change the value (e.g., type "30")
   - Tap outside to confirm
   - Verify the timer restarts from the new value (30 seconds, full bar, counting down)

6. **Finish with rest time save test:**
   - Change a rest time on one exercise (e.g., change from 1:30 to 2:00)
   - Finish the workout (tap Finish -> Save)
   - Start a new workout from the same template
   - Verify the changed exercise now shows "2:00" as its default rest time

7. **Cancel/discard test:**
   - Change a rest time on one exercise
   - Cancel the workout (tap Cancel -> Discard)
   - Start a new workout from the same template
   - Verify the rest time is unchanged (original value, not the edited value)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- App launches without crashes when navigating to workout screen
- updateTemplate payload uses activeWorkout.exercises[].rest_seconds (includes session edits)
- All seven test scenarios in human verification pass
</verification>

<success_criteria>
Rest timer is visible and editable from the moment a workout starts. Users can see the current rest time, adjust via +/-10s buttons (functional immediately), and tap the time display to edit directly. Rest time changes auto-save to template on finish and are discarded on cancel. Verified on physical device.
</success_criteria>

<output>
After completion, create `.planning/phases/09-timer-fixes/09-03-SUMMARY.md`
</output>
