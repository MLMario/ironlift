---
phase: 09-timer-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/timeUtils.ts
  - src/components/RestTimerInline.tsx
  - src/hooks/useRestTimer.ts
  - src/hooks/useWorkoutState.ts
autonomous: true

must_haves:
  truths:
    - "parseTimeInput and formatTime are importable from a shared utility module"
    - "RestTimerInline still functions identically after refactor to shared utilities"
    - "useRestTimer exposes a pause() method that stops countdown and returns remaining seconds"
    - "useRestTimer.start() can restart a timer with a new duration"
    - "useWorkoutState exposes updateRestSeconds(exerciseIndex, seconds) mutation"
    - "useWorkoutState exposes getRestTimeChanges() returning array of exercises with changed rest times"
    - "TemplateSnapshot includes rest_seconds per exercise for dirty tracking"
  artifacts:
    - path: "src/lib/timeUtils.ts"
      provides: "Shared time parse/format/clamp utilities"
      exports: ["formatTime", "parseTimeInput", "clampSeconds"]
    - path: "src/hooks/useRestTimer.ts"
      provides: "Rest timer with pause and restart capabilities"
      exports: ["useRestTimer"]
    - path: "src/hooks/useWorkoutState.ts"
      provides: "Workout state with rest time mutation and dirty tracking"
      exports: ["useWorkoutState", "TemplateSnapshot"]
  key_links:
    - from: "src/components/RestTimerInline.tsx"
      to: "src/lib/timeUtils.ts"
      via: "import { formatTime, parseTimeInput }"
      pattern: "import.*from.*@/lib/timeUtils"
    - from: "src/hooks/useWorkoutState.ts"
      to: "TemplateSnapshot"
      via: "rest_seconds field in snapshot exercises"
      pattern: "rest_seconds.*number"
---

<objective>
Extract shared time utilities, add pause/restart to rest timer hook, and add rest time mutation with dirty tracking to workout state hook.

Purpose: These are the foundational changes that all subsequent plans depend on -- shared parsing logic, timer pause capability for mid-countdown editing, and the state mutation + change detection needed for session-scoped rest time editing with auto-save on finish.

Output: Four modified/created files providing the utility and hook layer for the timer fixes phase.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-timer-fixes/09-CONTEXT.md
@.planning/phases/09-timer-fixes/09-RESEARCH.md
@src/lib/timeUtils.ts
@src/components/RestTimerInline.tsx
@src/hooks/useRestTimer.ts
@src/hooks/useWorkoutState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared time utilities and update RestTimerInline</name>
  <files>src/lib/timeUtils.ts, src/components/RestTimerInline.tsx</files>
  <action>
Create `src/lib/timeUtils.ts` with three exported functions extracted/enhanced from RestTimerInline:

1. `formatTime(seconds: number): string` -- identical to RestTimerInline's version. Converts seconds to "M:SS" format (e.g., 90 -> "1:30", 0 -> "0:00"). Clamp input to Math.max(0, seconds) before formatting.

2. `parseTimeInput(input: string): number | null` -- enhanced version of RestTimerInline's. Key differences from the original:
   - Empty string or whitespace-only -> return `null` (not 0). This distinguishes "unparseable" from "parsed as zero".
   - Contains ":" -> split on ":", parse minutes and seconds as integers. If BOTH parts are NaN, return null. Otherwise treat NaN parts as 0 (e.g., ":30" -> 30s, "1:" -> 60s). Return mins*60+secs. If result < 0, return null.
   - Plain number -> parseInt. If NaN, return null. If negative, return null. Otherwise return the integer.
   - Note: "0" should parse to 0 (not null). This is a valid input that the caller will clamp to bounds.

3. `clampSeconds(seconds: number, min: number, max: number): number` -- returns Math.max(min, Math.min(max, seconds)). Simple bounds clamping.

Then update `RestTimerInline.tsx`:
- Remove the local `formatTime` and `parseTimeInput` function definitions.
- Add import: `import { formatTime, parseTimeInput } from '@/lib/timeUtils';`
- Update `handleBlur` to handle the new null return: if `parseTimeInput(editingText)` returns null, treat as 0 (matching RestTimerInline's original behavior where empty/invalid -> 0). This preserves backward compatibility for the template editor where 0 is valid.
- Keep everything else identical -- no other changes to RestTimerInline.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify that `src/lib/timeUtils.ts` exports all three functions. Verify that `RestTimerInline.tsx` no longer has local formatTime/parseTimeInput definitions and imports from `@/lib/timeUtils`.
  </verify>
  <done>
timeUtils.ts exists with formatTime, parseTimeInput (returns null for unparseable), and clampSeconds. RestTimerInline imports from timeUtils and behaves identically to before (template editor rest time input unchanged).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pause/restart to useRestTimer and rest time mutation to useWorkoutState</name>
  <files>src/hooks/useRestTimer.ts, src/hooks/useWorkoutState.ts</files>
  <action>
**useRestTimer.ts changes:**

1. Add a `pause()` method:
   - Signature: `pause(): Promise<void>`
   - Reads `timerParamsRef.current` -- if null, return early (no active timer)
   - Calculates remaining: `Math.max(0, params.duration - Math.floor((Date.now() - params.startedAt) / 1000))`
   - Calls `clearTimer()` to stop the interval
   - Calls `await cancelNotification()` to cancel scheduled notification
   - Does NOT reset `timerParamsRef.current` to null (unlike stop())
   - Does NOT change timer state to idle (unlike stop()). The state remains 'active' so the parent knows a timer was paused. The parent (RestTimerBar) will manage the transition to editing mode.
   - Actually, to properly track the paused state, update the timer state remaining to the calculated value (freeze it in place): `setTimer(prev => prev.status === 'active' ? { ...prev, remaining } : prev)`

2. Modify `start()`:
   - Currently: `start(exerciseIndex: number, totalSeconds: number)`
   - Keep same signature. The function already handles being called when a timer is active (it clears first). No changes needed to start() -- it already works for restart scenarios. The caller (workout.tsx or RestTimerBar callback) will call `start(exerciseIndex, newDuration)` after editing to restart from the new value.

3. Add `pause` to the returned object alongside existing `start`, `stop`, `adjust`, etc.

**useWorkoutState.ts changes:**

1. Extend `TemplateSnapshot` interface to include `rest_seconds` per exercise:
   ```typescript
   export interface TemplateSnapshot {
     exercises: {
       exercise_id: string;
       rest_seconds: number;  // NEW: original rest time for dirty tracking
       sets: {
         set_number: number;
         weight: number;
         reps: number;
       }[];
     }[];
   }
   ```

2. Update the snapshot creation in the `useEffect` initialization block to include `rest_seconds`:
   ```typescript
   const snapshot: TemplateSnapshot = {
     exercises: template.exercises.map((te) => ({
       exercise_id: te.exercise_id,
       rest_seconds: te.default_rest_seconds || 90,  // NEW
       sets: te.sets.map((set) => ({
         set_number: set.set_number,
         weight: set.weight,
         reps: set.reps,
       })),
     })),
   };
   ```

3. Add `updateRestSeconds` mutation (follows existing pattern of updateSetWeight/updateSetReps):
   ```typescript
   const updateRestSeconds = useCallback(
     (exerciseIndex: number, seconds: number): void => {
       setActiveWorkout((prev) => {
         const exercises = [...prev.exercises];
         const exercise = { ...exercises[exerciseIndex] };
         exercise.rest_seconds = seconds;
         exercises[exerciseIndex] = exercise;
         return { ...prev, exercises };
       });
     },
     []
   );
   ```

4. Add `getRestTimeChanges()` function:
   - Signature: `getRestTimeChanges(): Array<{ exercise_id: string; rest_seconds: number }>`
   - If `originalTemplateSnapshot` is null, return empty array
   - For each exercise in `activeWorkout.exercises`, find matching exercise in `originalTemplateSnapshot.exercises` by `exercise_id`
   - If no match (exercise added during workout), skip it
   - If match found and `rest_seconds` differs from original, include in result
   - Return array of `{ exercise_id, rest_seconds }` for changed exercises only
   - Wrap in useCallback with deps: `[originalTemplateSnapshot, activeWorkout.exercises]`

5. Add `updateRestSeconds` and `getRestTimeChanges` to the returned object.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify useRestTimer returns `pause` in its return object. Verify useWorkoutState returns `updateRestSeconds` and `getRestTimeChanges` in its return object. Verify TemplateSnapshot has `rest_seconds` field.
  </verify>
  <done>
useRestTimer exposes pause() that freezes timer state without resetting to idle. useWorkoutState exposes updateRestSeconds(exerciseIndex, seconds) for session-scoped rest time changes and getRestTimeChanges() for dirty detection. TemplateSnapshot includes rest_seconds per exercise. No type errors.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/lib/timeUtils.ts` exports formatTime, parseTimeInput, clampSeconds
- parseTimeInput("90") returns 90, parseTimeInput("1:30") returns 90, parseTimeInput("") returns null, parseTimeInput("abc") returns null, parseTimeInput("0") returns 0
- clampSeconds(5, 10, 600) returns 10, clampSeconds(700, 10, 600) returns 600
- RestTimerInline.tsx imports from @/lib/timeUtils (no local parse/format functions)
- useRestTimer return object includes { timer, start, stop, adjust, pause, isActiveForExercise, getProgress }
- useWorkoutState return object includes { ..., updateRestSeconds, getRestTimeChanges }
</verification>

<success_criteria>
Shared time utilities extracted, useRestTimer has pause capability, useWorkoutState has rest time mutation and dirty tracking. All existing functionality preserved. TypeScript compiles cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/09-timer-fixes/09-01-SUMMARY.md`
</output>
