---
phase: 09-timer-fixes
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/components/RestTimerBar.tsx
  - src/components/WorkoutExerciseCard.tsx
autonomous: true

must_haves:
  truths:
    - "RestTimerBar shows exercise rest time in INACTIVE state with full progress fill"
    - "Tapping the time text in RestTimerBar enters EDITING mode with auto-focused TextInput"
    - "TextInput accepts both plain seconds and MM:SS format with validation and clamping"
    - "Blur on TextInput confirms edit -- parseable input is clamped to 10-600s bounds, unparseable reverts"
    - "+/-10s buttons work in all three modes (inactive, editing, active)"
    - "Tapping time text during active countdown pauses timer and opens edit mode"
    - "After edit confirm during active timer, countdown restarts from new value"
    - "Every exercise card shows RestTimerBar immediately on workout load (isExpanded defaults to true)"
    - "RestTimerBar shows 0:00 for exercises with rest_seconds = 0 and allows tap to edit"
  artifacts:
    - path: "src/components/RestTimerBar.tsx"
      provides: "Three-state timer bar with inline editing"
      min_lines: 100
    - path: "src/components/WorkoutExerciseCard.tsx"
      provides: "Exercise card with new timer props and correct default expansion"
  key_links:
    - from: "src/components/RestTimerBar.tsx"
      to: "src/lib/timeUtils.ts"
      via: "import { formatTime, parseTimeInput, clampSeconds }"
      pattern: "import.*from.*@/lib/timeUtils"
    - from: "src/components/WorkoutExerciseCard.tsx"
      to: "src/components/RestTimerBar.tsx"
      via: "RestTimerBar props including onRestTimeChange, onTimerPause, onTimerRestart"
      pattern: "onRestTimeChange|onTimerPause|onTimerRestart"
---

<objective>
Overhaul RestTimerBar to support three visual states (INACTIVE/EDITING/ACTIVE) with inline TextInput editing, and update WorkoutExerciseCard to wire the new props and fix the isExpanded default.

Purpose: This is the core UI change of the phase -- making the rest timer bar an interactive, editable control that works from the moment the workout starts, not just during active countdown.

Output: Two modified component files implementing the dual-mode bar design and correct card expansion behavior.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-timer-fixes/09-CONTEXT.md
@.planning/phases/09-timer-fixes/09-RESEARCH.md
@.planning/phases/09-timer-fixes/09-01-SUMMARY.md
@src/components/RestTimerBar.tsx
@src/components/WorkoutExerciseCard.tsx
@src/lib/timeUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Overhaul RestTimerBar state machine and rendering</name>
  <files>src/components/RestTimerBar.tsx</files>
  <action>
Rewrite RestTimerBar to support INACTIVE/EDITING/ACTIVE states. Import shared utilities: `import { formatTime, parseTimeInput, clampSeconds } from '@/lib/timeUtils';`

**New props interface:**
```typescript
interface RestTimerBarProps {
  remainingSeconds: number;
  totalSeconds: number;
  isActive: boolean;
  restSeconds: number;           // Exercise's configured rest time (from workout state)
  onAdjust: (delta: number) => void;           // Adjust active timer mid-countdown
  onRestTimeChange: (seconds: number) => void; // Update rest_seconds in workout state
  onTimerPause: () => void;                    // Pause active timer for editing
  onTimerRestart: (seconds: number) => void;   // Restart timer from new value after edit
}
```

**Internal state:**
- `mode: 'inactive' | 'editing'` -- local state. The effective display mode is: if `mode === 'editing'` -> 'editing'; else if `isActive` prop -> 'active'; else 'inactive'.
- `editText: string` -- current TextInput value during editing
- `inputRef: useRef<TextInput>(null)` -- for imperative focus management
- `wasActiveBeforeEdit: useRef<boolean>(false)` -- tracks whether timer was active when edit started (to know whether to restart on confirm)

**INACTIVE state rendering:**
- Progress bar at 100% fill, color = theme.colors.textMuted (matches existing inactive style)
- Time text shows `formatTime(restSeconds)` -- the exercise's configured rest time
- Time text is wrapped in a Pressable with onPress = handleTimeTextPress
- +/-10s buttons visible and functional

**EDITING state rendering:**
- Progress bar at 100% fill, color = theme.colors.accent (visual indicator of edit mode)
- TextInput replaces the time text in the timeOverlay area
- TextInput: `autoFocus`, `keyboardType="numbers-and-punctuation"`, `selectTextOnFocus`, `textAlign="center"`, value={editText}, onChangeText={setEditText}, onBlur={handleBlur}
- TextInput styling: same font size/family as timeText, cursor color = theme.colors.accent, transparent background so bar shows through
- +/-10s buttons visible and functional -- they parse current editText, apply delta with clamping, update editText display

**ACTIVE state rendering:**
- Progress bar with shrinking fill (existing behavior), color = theme.colors.accent
- Time text shows `formatTime(remainingSeconds)` -- the countdown value
- Time text is STILL wrapped in Pressable (tappable to enter edit mode per locked decision)
- +/-10s buttons visible and functional (existing adjust behavior + update restSeconds)

**Progress bar percentage calculation:**
- INACTIVE: 100% (full bar)
- EDITING: 100% (full bar)
- ACTIVE: `(remainingSeconds / totalSeconds) * 100`

**Display time calculation:**
- INACTIVE: `formatTime(restSeconds)`
- EDITING: n/a (TextInput shown instead)
- ACTIVE: `formatTime(remainingSeconds)`

Remove the old local `formatTime` function (now imported from timeUtils).

**Styles additions:**
- `editInput`: same fontSize as timeText (theme.typography.sizes.sm), same fontFamily (theme.typography.fontFamilyMono), same fontWeight (theme.typography.weights.medium), color = theme.colors.textPrimary, backgroundColor = 'transparent', width = 60 (enough for "10:00"), height matches timeOverlay, padding 0, textAlign 'center'. No explicit border.
- `timeTextPressable`: add hitSlop={8} for tap target on the time text only (not the whole bar per locked decision)

**Mid-task verification:** After completing rendering and styles, run `npx tsc --noEmit` to confirm the component type-checks before proceeding to handler implementation.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Visually inspect the component structure: INACTIVE shows Pressable-wrapped Text, EDITING shows TextInput with autoFocus, ACTIVE shows Pressable-wrapped countdown Text.
  </verify>
  <done>
RestTimerBar renders three visual states correctly. INACTIVE shows full bar with tappable time text. EDITING shows TextInput in the time overlay area. ACTIVE shows countdown with tappable time text. Progress bar colors and fill percentages are correct per state. Styles are applied. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement RestTimerBar handlers and wire WorkoutExerciseCard</name>
  <files>src/components/RestTimerBar.tsx, src/components/WorkoutExerciseCard.tsx</files>
  <action>
**RestTimerBar handler implementation (continuing from Task 1's rendered component):**

`handleTimeTextPress`:
- If isActive: call `onTimerPause()`, set `wasActiveBeforeEdit.current = true`
- Else: set `wasActiveBeforeEdit.current = false`
- Set `editText` to `formatTime(restSeconds)` (always show configured rest time, not remaining countdown time)
- Set `mode` to 'editing'
- After state update, focus TextInput via `setTimeout(() => inputRef.current?.focus(), 50)` (small delay for mount)

`handleBlur` (fires when TextInput loses focus = tap outside):
- Parse `editText` via `parseTimeInput(editText)`
- If result is `null` (unparseable): do nothing to rest time (revert behavior per locked decision)
- If result is a number: clamp to 10-600 via `clampSeconds(parsed, 10, 600)`, call `onRestTimeChange(clamped)`
- If `wasActiveBeforeEdit.current` is true AND the parse succeeded:
  - Call `onTimerRestart(clamped)` to restart countdown from the new value
  - Reset `wasActiveBeforeEdit.current = false`
- If `wasActiveBeforeEdit.current` is true AND parse failed:
  - Call `onTimerRestart(restSeconds)` to restart from original value
  - Reset `wasActiveBeforeEdit.current = false`
- Set `mode` to 'inactive'

`handleAdjustInEditMode(delta)` -- called when +/-10s pressed during EDITING:
- Parse current `editText` via `parseTimeInput(editText)`
- If null: no-op (per locked decision: buttons are no-ops for unparseable input)
- If number: apply delta, clamp to 10-600, update `editText` to `formatTime(newValue)`
- Do NOT call onRestTimeChange here (wait for blur confirmation)
- Do NOT trigger blur -- the TextInput should stay focused. Use `onPressIn` on the button Pressables instead of `onPress` to help prevent focus steal issues.

`handleAdjustNormal(delta)` -- called when +/-10s pressed during INACTIVE or ACTIVE:
- Compute `newVal = clampSeconds(restSeconds + delta, 10, 600)`
- Call `onRestTimeChange(newVal)` to persist the new base rest time in workout state
- If `isActive`: ALSO call `onAdjust(delta)` to adjust the running timer countdown. The two calls serve different purposes: `onRestTimeChange(newVal)` updates the exercise's stored rest_seconds (persisted on finish), while `onAdjust(delta)` adjusts the currently ticking countdown by the delta amount. Both fire with the same user action (+/-10s press during active countdown).

**Button handler routing:**
The +/-10s button onPress should route to the correct handler based on effective mode:
- If mode === 'editing': call handleAdjustInEditMode(delta)
- Else: call handleAdjustNormal(delta)

**Blur vs button race condition mitigation:**
The parent ScrollView has `keyboardShouldPersistTaps="handled"`. This means pressing a button while TextInput is focused should NOT cause blur BEFORE the press event. However, as extra safety, the +/-10s buttons during editing mode should use `onPressIn` to register immediately. The buttons must NOT cause the TextInput to blur -- they operate on the editText value directly without changing mode.

**WorkoutExerciseCard changes:**

1. Fix isExpanded default (bug fix per decision [05-04]):
Line 90: Change `const [isExpanded, setIsExpanded] = useState(false);` to `const [isExpanded, setIsExpanded] = useState(true);`
This ensures all exercise cards start expanded, making the RestTimerBar visible from workout load.

2. Add new timer props to interface and pass to RestTimerBar:

Update `WorkoutExerciseCardProps` interface -- add these new props:
```typescript
  restSeconds: number;                           // Exercise's configured rest time
  onRestTimeChange: (seconds: number) => void;   // Update rest_seconds in workout state
  onTimerPause: () => void;                       // Pause active timer for editing
  onTimerRestart: (seconds: number) => void;      // Restart timer from new value
```

Update the component function parameter destructuring to include the new props.

Update the RestTimerBar usage in the render to pass the new props:
```tsx
<RestTimerBar
  remainingSeconds={timerRemaining}
  totalSeconds={timerTotal}
  isActive={isTimerActive}
  restSeconds={restSeconds}
  onAdjust={onAdjustTimer}
  onRestTimeChange={onRestTimeChange}
  onTimerPause={onTimerPause}
  onTimerRestart={onTimerRestart}
/>
```

No other changes to the component -- all logic for editing state management lives inside RestTimerBar per the anti-pattern guidance ("Don't lift editing state to workout.tsx").
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Confirm RestTimerBar has all handlers implemented with correct routing logic. Confirm isExpanded default is true. Confirm RestTimerBar receives all new props from WorkoutExerciseCard.
  </verify>
  <done>
RestTimerBar has complete handler implementation: handleTimeTextPress enters edit mode (pauses timer if active), handleBlur confirms/reverts, handleAdjustInEditMode updates editText, handleAdjustNormal persists rest time AND adjusts running countdown. WorkoutExerciseCard defaults to expanded (isExpanded=true) and passes all new props to RestTimerBar. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- RestTimerBar accepts and uses: restSeconds, onRestTimeChange, onTimerPause, onTimerRestart props
- RestTimerBar imports formatTime, parseTimeInput, clampSeconds from @/lib/timeUtils
- RestTimerBar has local mode state ('inactive' | 'editing') and determines effective display from mode + isActive
- handleAdjustNormal calls BOTH onRestTimeChange(newVal) AND onAdjust(delta) when isActive
- handleBlur reverts on null parseTimeInput result (does not call onRestTimeChange)
- WorkoutExerciseCard isExpanded defaults to true (useState(true))
- WorkoutExerciseCard passes all new props to RestTimerBar
</verification>

<success_criteria>
RestTimerBar is a three-state interactive component with inline TextInput editing. WorkoutExerciseCard shows the timer bar immediately on load. TypeScript compiles cleanly. Components are ready to be wired by workout.tsx.
</success_criteria>

<output>
After completion, create `.planning/phases/09-timer-fixes/09-02-SUMMARY.md`
</output>
