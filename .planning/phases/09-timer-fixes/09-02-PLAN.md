---
phase: 09-timer-fixes
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/components/RestTimerBar.tsx
  - src/components/WorkoutExerciseCard.tsx
autonomous: true

must_haves:
  truths:
    - "RestTimerBar shows exercise rest time in INACTIVE state with full progress fill"
    - "Tapping the time text in RestTimerBar enters EDITING mode with auto-focused TextInput"
    - "TextInput accepts both plain seconds and MM:SS format with validation and clamping"
    - "Blur on TextInput confirms edit -- parseable input is clamped to 10-600s bounds, unparseable reverts"
    - "+/-10s buttons work in all three modes (inactive, editing, active)"
    - "Tapping time text during active countdown pauses timer and opens edit mode"
    - "After edit confirm during active timer, countdown restarts from new value"
    - "Every exercise card shows RestTimerBar immediately on workout load (isExpanded defaults to true)"
    - "RestTimerBar shows 0:00 for exercises with rest_seconds = 0 and allows tap to edit"
  artifacts:
    - path: "src/components/RestTimerBar.tsx"
      provides: "Three-state timer bar with inline editing"
      min_lines: 100
    - path: "src/components/WorkoutExerciseCard.tsx"
      provides: "Exercise card with new timer props and correct default expansion"
  key_links:
    - from: "src/components/RestTimerBar.tsx"
      to: "src/lib/timeUtils.ts"
      via: "import { formatTime, parseTimeInput, clampSeconds }"
      pattern: "import.*from.*@/lib/timeUtils"
    - from: "src/components/WorkoutExerciseCard.tsx"
      to: "src/components/RestTimerBar.tsx"
      via: "RestTimerBar props including onRestTimeChange, onTimerPause, onTimerRestart"
      pattern: "onRestTimeChange|onTimerPause|onTimerRestart"
---

<objective>
Overhaul RestTimerBar to support three visual states (INACTIVE/EDITING/ACTIVE) with inline TextInput editing, and update WorkoutExerciseCard to wire the new props and fix the isExpanded default.

Purpose: This is the core UI change of the phase -- making the rest timer bar an interactive, editable control that works from the moment the workout starts, not just during active countdown.

Output: Two modified component files implementing the dual-mode bar design and correct card expansion behavior.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-timer-fixes/09-CONTEXT.md
@.planning/phases/09-timer-fixes/09-RESEARCH.md
@.planning/phases/09-timer-fixes/09-01-SUMMARY.md
@src/components/RestTimerBar.tsx
@src/components/WorkoutExerciseCard.tsx
@src/lib/timeUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Overhaul RestTimerBar with three-state editing</name>
  <files>src/components/RestTimerBar.tsx</files>
  <action>
Rewrite RestTimerBar to support INACTIVE/EDITING/ACTIVE states with inline TextInput. Import shared utilities: `import { formatTime, parseTimeInput, clampSeconds } from '@/lib/timeUtils';`

**New props interface:**
```typescript
interface RestTimerBarProps {
  remainingSeconds: number;
  totalSeconds: number;
  isActive: boolean;
  restSeconds: number;           // Exercise's configured rest time (from workout state)
  onAdjust: (delta: number) => void;           // Adjust active timer mid-countdown
  onRestTimeChange: (seconds: number) => void; // Update rest_seconds in workout state
  onTimerPause: () => void;                    // Pause active timer for editing
  onTimerRestart: (seconds: number) => void;   // Restart timer from new value after edit
}
```

**Internal state:**
- `mode: 'inactive' | 'editing'` -- local state. The effective display mode is: if `mode === 'editing'` -> 'editing'; else if `isActive` prop -> 'active'; else 'inactive'.
- `editText: string` -- current TextInput value during editing
- `inputRef: useRef<TextInput>(null)` -- for imperative focus management
- `wasActiveBeforeEdit: useRef<boolean>(false)` -- tracks whether timer was active when edit started (to know whether to restart on confirm)

**INACTIVE state rendering:**
- Progress bar at 100% fill, color = theme.colors.textMuted (matches existing inactive style)
- Time text shows `formatTime(restSeconds)` -- the exercise's configured rest time
- Time text is wrapped in a Pressable with onPress = handleTimeTextPress
- +/-10s buttons visible and functional

**EDITING state rendering:**
- Progress bar at 100% fill, color = theme.colors.accent (visual indicator of edit mode)
- TextInput replaces the time text in the timeOverlay area
- TextInput: `autoFocus`, `keyboardType="numbers-and-punctuation"`, `selectTextOnFocus`, `textAlign="center"`, value={editText}, onChangeText={setEditText}, onBlur={handleBlur}
- TextInput styling: same font size/family as timeText, cursor color = theme.colors.accent, transparent background so bar shows through
- +/-10s buttons visible and functional -- they parse current editText, apply delta with clamping, update editText display

**ACTIVE state rendering:**
- Progress bar with shrinking fill (existing behavior), color = theme.colors.accent
- Time text shows `formatTime(remainingSeconds)` -- the countdown value
- Time text is STILL wrapped in Pressable (tappable to enter edit mode per locked decision)
- +/-10s buttons visible and functional (existing adjust behavior + update restSeconds)

**Key handlers:**

`handleTimeTextPress`:
- If isActive: call `onTimerPause()`, set `wasActiveBeforeEdit.current = true`
- Else: set `wasActiveBeforeEdit.current = false`
- Set `editText` to `formatTime(restSeconds)` (always show configured rest time, not remaining countdown time)
- Set `mode` to 'editing'
- After state update, focus TextInput via `setTimeout(() => inputRef.current?.focus(), 50)` (small delay for mount)

`handleBlur` (fires when TextInput loses focus = tap outside):
- Parse `editText` via `parseTimeInput(editText)`
- If result is `null` (unparseable): do nothing to rest time (revert behavior per locked decision)
- If result is a number: clamp to 10-600 via `clampSeconds(parsed, 10, 600)`, call `onRestTimeChange(clamped)`
- If `wasActiveBeforeEdit.current` is true AND the parse succeeded:
  - Call `onTimerRestart(clamped)` to restart countdown from the new value
  - Reset `wasActiveBeforeEdit.current = false`
- If `wasActiveBeforeEdit.current` is true AND parse failed:
  - Call `onTimerRestart(restSeconds)` to restart from original value
  - Reset `wasActiveBeforeEdit.current = false`
- Set `mode` to 'inactive'

`handleAdjustInEditMode(delta)` -- called when +/-10s pressed during EDITING:
- Parse current `editText` via `parseTimeInput(editText)`
- If null: no-op (per locked decision: buttons are no-ops for unparseable input)
- If number: apply delta, clamp to 10-600, update `editText` to `formatTime(newValue)`
- Do NOT call onRestTimeChange here (wait for blur confirmation)
- Do NOT trigger blur -- the TextInput should stay focused. Use `onPressIn` on the button Pressables instead of `onPress` to help prevent focus steal issues.

`handleAdjustNormal(delta)` -- called when +/-10s pressed during INACTIVE or ACTIVE:
- Clamp: `const newVal = clampSeconds(restSeconds + delta, 10, 600)`
- Call `onRestTimeChange(newVal)` to persist in workout state
- If `isActive`: also call `onAdjust(delta)` to adjust the running countdown

**Button handler routing:**
The +/-10s button onPress should route to the correct handler based on effective mode:
- If mode === 'editing': call handleAdjustInEditMode(delta)
- Else: call handleAdjustNormal(delta)

**Blur vs button race condition mitigation:**
The parent ScrollView has `keyboardShouldPersistTaps="handled"`. This means pressing a button while TextInput is focused should NOT cause blur BEFORE the press event. However, as extra safety, the +/-10s buttons during editing mode should use `onPressIn` to register immediately. The buttons must NOT cause the TextInput to blur -- they operate on the editText value directly without changing mode.

**Progress bar percentage calculation:**
- INACTIVE: 100% (full bar)
- EDITING: 100% (full bar)
- ACTIVE: `(remainingSeconds / totalSeconds) * 100`

**Display time calculation:**
- INACTIVE: `formatTime(restSeconds)`
- EDITING: n/a (TextInput shown instead)
- ACTIVE: `formatTime(remainingSeconds)`

Remove the old local `formatTime` function (now imported from timeUtils).

**Styles additions:**
- `editInput`: same fontSize as timeText (theme.typography.sizes.sm), same fontFamily (theme.typography.fontFamilyMono), same fontWeight (theme.typography.weights.medium), color = theme.colors.textPrimary, backgroundColor = 'transparent', width = 60 (enough for "10:00"), height matches timeOverlay, padding 0, textAlign 'center'. No explicit border.
- `timeTextPressable`: add hitSlop={8} for tap target on the time text only (not the whole bar per locked decision)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Visually inspect the component structure: INACTIVE shows Pressable-wrapped Text, EDITING shows TextInput with autoFocus, ACTIVE shows Pressable-wrapped countdown Text.
  </verify>
  <done>
RestTimerBar supports three visual states (INACTIVE/EDITING/ACTIVE). Time text is tappable in INACTIVE and ACTIVE modes. EDITING mode shows auto-focused TextInput with blur-to-confirm. +/-10s buttons work in all modes. Pauses timer on edit during countdown and restarts on confirm.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update WorkoutExerciseCard with new timer props and isExpanded fix</name>
  <files>src/components/WorkoutExerciseCard.tsx</files>
  <action>
Two changes to WorkoutExerciseCard:

**1. Fix isExpanded default (bug fix per decision [05-04]):**
Line 90: Change `const [isExpanded, setIsExpanded] = useState(false);` to `const [isExpanded, setIsExpanded] = useState(true);`
This ensures all exercise cards start expanded, making the RestTimerBar visible from workout load.

**2. Add new timer props to interface and pass to RestTimerBar:**

Update `WorkoutExerciseCardProps` interface -- add these new props:
```typescript
  restSeconds: number;                           // Exercise's configured rest time
  onRestTimeChange: (seconds: number) => void;   // Update rest_seconds in workout state
  onTimerPause: () => void;                       // Pause active timer for editing
  onTimerRestart: (seconds: number) => void;      // Restart timer from new value
```

Update the component function parameter destructuring to include the new props.

Update the RestTimerBar usage in the render to pass the new props:
```tsx
<RestTimerBar
  remainingSeconds={timerRemaining}
  totalSeconds={timerTotal}
  isActive={isTimerActive}
  restSeconds={restSeconds}
  onAdjust={onAdjustTimer}
  onRestTimeChange={onRestTimeChange}
  onTimerPause={onTimerPause}
  onTimerRestart={onTimerRestart}
/>
```

No other changes to the component -- all logic for editing state management lives inside RestTimerBar per the anti-pattern guidance ("Don't lift editing state to workout.tsx").
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Confirm isExpanded default is true. Confirm RestTimerBar receives all new props.
  </verify>
  <done>
WorkoutExerciseCard defaults to expanded (isExpanded=true). RestTimerBar receives restSeconds, onRestTimeChange, onTimerPause, and onTimerRestart props. All exercise cards show their timer bar immediately on workout load.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- RestTimerBar accepts and uses: restSeconds, onRestTimeChange, onTimerPause, onTimerRestart props
- RestTimerBar imports formatTime, parseTimeInput, clampSeconds from @/lib/timeUtils
- RestTimerBar has local mode state ('inactive' | 'editing') and determines effective display from mode + isActive
- WorkoutExerciseCard isExpanded defaults to true (useState(true))
- WorkoutExerciseCard passes all new props to RestTimerBar
</verification>

<success_criteria>
RestTimerBar is a three-state interactive component with inline TextInput editing. WorkoutExerciseCard shows the timer bar immediately on load. TypeScript compiles cleanly. Components are ready to be wired by workout.tsx.
</success_criteria>

<output>
After completion, create `.planning/phases/09-timer-fixes/09-02-SUMMARY.md`
</output>
