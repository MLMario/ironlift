---
phase: 11-silent-save-weight-reps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/templates.ts
  - src/hooks/useWorkoutState.ts
  - app/workout.tsx
autonomous: true

must_haves:
  truths:
    - "User changes weight on a set during workout, finishes workout -> template reflects new weight"
    - "User changes reps on a set during workout, finishes workout -> template reflects new reps"
    - "Silent save does not trigger the template update confirmation modal"
    - "Cancelled/discarded workout saves nothing to template"
    - "Only sets marked as done at save time have their values saved"
    - "Sets beyond template count are ignored (extra workout sets not saved)"
    - "If user confirmed the template update modal, silent save is skipped entirely"
    - "If user declined the template update modal, silent save still fires for matching-position sets"
    - "Existing rest timer silent save behavior is unaffected"
  artifacts:
    - path: "src/services/templates.ts"
      provides: "updateTemplateExerciseSetValues() function for targeted set updates"
      exports: ["updateTemplateExerciseSetValues"]
    - path: "src/hooks/useWorkoutState.ts"
      provides: "getWeightRepsChanges() function for detecting completed set values"
      exports: ["getWeightRepsChanges (via hook return)"]
    - path: "app/workout.tsx"
      provides: "saveWeightRepsChanges() wired into saveWorkoutAndCleanup + cache refresh"
  key_links:
    - from: "app/workout.tsx"
      to: "src/services/templates.ts"
      via: "import and call updateTemplateExerciseSetValues"
      pattern: "updateTemplateExerciseSetValues"
    - from: "app/workout.tsx"
      to: "src/hooks/useWorkoutState.ts"
      via: "getWeightRepsChanges from useWorkoutState hook return"
      pattern: "getWeightRepsChanges"
    - from: "app/workout.tsx saveWeightRepsChanges()"
      to: "saveWorkoutAndCleanup(false)"
      via: "called alongside saveRestTimeChanges() when shouldUpdateTemplate === false"
      pattern: "saveWeightRepsChanges"
    - from: "app/workout.tsx"
      to: "src/lib/cache.ts"
      via: "template cache refresh after successful silent save"
      pattern: "getTemplates.*setCachedTemplates|getCachedTemplates"
---

<objective>
Add silent save of weight/reps values from completed workout sets back to the template when a workout is finished, matching the existing rest timer silent save pattern.

Purpose: When users adjust weights/reps during a workout and finish, the template should remember those values for next time -- without any confirmation prompts. This completes the "template learns from your workouts" behavior that already exists for rest timers.

Output: Modified templates.ts (new service function), useWorkoutState.ts (new change detection function), workout.tsx (wiring + cache refresh)
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-silent-save-weight-reps/11-CONTEXT.md
@.planning/phases/11-silent-save-weight-reps/11-RESEARCH.md
@src/services/templates.ts
@src/hooks/useWorkoutState.ts
@app/workout.tsx
@src/lib/cache.ts
@src/types/services.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service function and hook change detection</name>
  <files>src/services/templates.ts, src/hooks/useWorkoutState.ts</files>
  <action>
**In `src/services/templates.ts`:**

Add a new standalone exported function `updateTemplateExerciseSetValues()` BELOW the existing `templates` service object export. This function is NOT added to the TemplatesService interface or the `templates` object -- it is a named export used only by the silent save flow.

```typescript
export interface TemplateSetValueUpdate {
  set_number: number;
  weight: number;
  reps: number;
}

export async function updateTemplateExerciseSetValues(
  templateId: string,
  exerciseId: string,
  setUpdates: TemplateSetValueUpdate[]
): Promise<void> {
  if (setUpdates.length === 0) return;

  // Look up the template_exercise_id from (template_id, exercise_id)
  // This is necessary because template_exercise_sets uses template_exercise_id, not exercise_id
  const { data: templateExercise, error: lookupError } = await supabase
    .from('template_exercises')
    .select('id')
    .eq('template_id', templateId)
    .eq('exercise_id', exerciseId)
    .single();

  if (lookupError || !templateExercise) return; // Best-effort: skip silently

  // Update each set individually using the UNIQUE (template_exercise_id, set_number) constraint
  for (const update of setUpdates) {
    await supabase
      .from('template_exercise_sets')
      .update({ weight: update.weight, reps: update.reps })
      .eq('template_exercise_id', templateExercise.id)
      .eq('set_number', update.set_number);
    // Individual set errors are silently ignored (best-effort)
  }
}
```

Key details:
- The `supabase` import already exists at the top of the file -- reuse it
- Export the `TemplateSetValueUpdate` interface so the workout screen can reference it if needed
- Do NOT modify the existing `templates` object or `TemplatesService` interface
- No auth check needed -- RLS handles authorization at the database level (matching the pattern in `updateTemplateExercise` but simplified since this is best-effort)
- Actually, looking more carefully at `updateTemplateExercise`, it DOES check auth. However, for this best-effort silent save, skip the auth check. The user is already authenticated (they just completed a workout). If the Supabase call fails due to auth, it will fail silently which is the correct behavior.

**In `src/hooks/useWorkoutState.ts`:**

Add a new `getWeightRepsChanges` callback function in the MUTATION FUNCTIONS section, right after the existing `getRestTimeChanges` function. Follow the exact same pattern.

```typescript
/**
 * Get completed set weight/reps values for silent save to template.
 * For each exercise in the original template, collects all done sets
 * where set_number <= template set count.
 * Used on workout finish to auto-save weight/reps changes silently.
 */
const getWeightRepsChanges = useCallback(
  (): Array<{
    exercise_id: string;
    sets: Array<{ set_number: number; weight: number; reps: number }>;
  }> => {
    if (!originalTemplateSnapshot) return [];

    const changes: Array<{
      exercise_id: string;
      sets: Array<{ set_number: number; weight: number; reps: number }>;
    }> = [];

    for (const exercise of activeWorkout.exercises) {
      // Skip exercises added during workout (not in original template)
      const original = originalTemplateSnapshot.exercises.find(
        (e) => e.exercise_id === exercise.exercise_id
      );
      if (!original) continue;

      const templateSetCount = original.sets.length;
      const setsToSave: Array<{ set_number: number; weight: number; reps: number }> = [];

      for (const set of exercise.sets) {
        // Only include sets that are marked done AND within template set count
        if (set.is_done && set.set_number <= templateSetCount) {
          setsToSave.push({
            set_number: set.set_number,
            weight: set.weight,
            reps: set.reps,
          });
        }
      }

      if (setsToSave.length > 0) {
        changes.push({
          exercise_id: exercise.exercise_id,
          sets: setsToSave,
        });
      }
    }

    return changes;
  },
  [originalTemplateSnapshot, activeWorkout.exercises]
);
```

Then add `getWeightRepsChanges` to the hook's return object, right after `getRestTimeChanges`:

```typescript
return {
  // ... existing properties ...
  getRestTimeChanges,
  getWeightRepsChanges,  // ADD THIS
};
```

Key details:
- No diffing -- per locked decision, always overwrite completed sets (no comparison against template values needed)
- set_number matching is positional (set 1 -> template set 1)
- Sets beyond template count are ignored per locked decision
- Exercises added during workout (not in originalTemplateSnapshot) are skipped
- Only sets with `is_done === true` are included per locked decision
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. No new type errors should appear. Verify the new function and hook method exist by checking the file contents.
  </verify>
  <done>
- `updateTemplateExerciseSetValues()` exported from templates.ts with correct Supabase queries targeting template_exercise_sets by (template_exercise_id, set_number)
- `getWeightRepsChanges()` available in useWorkoutState hook return value, correctly filtering by is_done and set_number <= template set count
- No type errors in the project
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire silent save into workout finish flow with cache refresh</name>
  <files>app/workout.tsx</files>
  <action>
**In `app/workout.tsx`:**

Three changes are needed:

**Change 1: Add import for the new service function and cache functions**

Add to the existing imports at the top:

```typescript
import { updateTemplateExerciseSetValues } from '@/services/templates';
```

Also add `setCachedTemplates` to the existing cache import (it already imports `getCachedTemplates`):

```typescript
import { getCachedTemplates, setCachedTemplates } from '@/lib/cache';
```

**Change 2: Add `getWeightRepsChanges` to the hook destructuring**

In the `useWorkoutState` destructuring (around line 133-149), add `getWeightRepsChanges`:

```typescript
const {
  // ... existing properties ...
  getRestTimeChanges,
  getWeightRepsChanges,  // ADD THIS
} = useWorkoutState(template, restoredBackup);
```

**Change 3: Add `saveWeightRepsChanges` function and wire it into `saveWorkoutAndCleanup`**

Add a new async function `saveWeightRepsChanges` right after the existing `saveRestTimeChanges` function (around line 322):

```typescript
/**
 * Silent weight/reps save -- persists per-set weight/reps changes to template.
 * Called on finish when NOT doing a structural update (structural update already
 * includes weight/reps via the full template replace).
 * Best-effort: skip silently on failure per locked decision.
 * After successful saves, refreshes the template cache so next workout uses updated values.
 */
async function saveWeightRepsChanges(): Promise<void> {
  const changes = getWeightRepsChanges();
  if (changes.length === 0) return;
  if (!activeWorkout.template_id) return;

  let anySaved = false;

  for (const change of changes) {
    try {
      await updateTemplateExerciseSetValues(
        activeWorkout.template_id,
        change.exercise_id,
        change.sets
      );
      anySaved = true;
    } catch {
      // Best-effort per locked decision -- skip silently on failure
    }
  }

  // Refresh template cache after successful saves so next workout uses updated values
  if (anySaved) {
    try {
      const { data: freshTemplates } = await templatesService.getTemplates();
      if (freshTemplates) {
        await setCachedTemplates(freshTemplates);
      }
    } catch {
      // Cache refresh failure is non-critical -- template DB is already updated
    }
  }
}
```

Then wire it into `saveWorkoutAndCleanup`. Find the block (around line 351):

```typescript
if (!shouldUpdateTemplate) {
  await saveRestTimeChanges();
}
```

Change it to:

```typescript
if (!shouldUpdateTemplate) {
  await saveRestTimeChanges();
  await saveWeightRepsChanges();
}
```

**Change 4: Update useCallback dependency array**

The `saveWorkoutAndCleanup` useCallback has a dependency array (around line 416). Add `getWeightRepsChanges` to it:

```typescript
}, [activeWorkout, stopTimer, backup, router, getRestTimeChanges, getWeightRepsChanges]);
```

Note: `getWeightRepsChanges` needs to be in the dependency array because `saveWeightRepsChanges` (called within `saveWorkoutAndCleanup`) calls it. The existing `getRestTimeChanges` is already there for the same reason.

**Important behavioral notes per locked decisions:**
- When `shouldUpdateTemplate === true` (user confirmed the template update modal), `saveWeightRepsChanges()` is NOT called. The full `updateTemplate()` already replaces all exercises and sets including weight/reps values. This prevents the dangerous scenario from Pitfall 2 in the research where silent save targets old template_exercise_ids that were deleted by updateTemplate().
- When `shouldUpdateTemplate === false` (no structural changes OR user declined the modal), `saveWeightRepsChanges()` fires alongside `saveRestTimeChanges()`.
- On cancelled/discarded workout, `saveWorkoutAndCleanup` is never called -- the cancel flow just clears backup and navigates back. No silent save occurs.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. No new type errors should appear. Then manually verify by reading the file that:
1. `saveWeightRepsChanges()` is called inside `saveWorkoutAndCleanup` in the `!shouldUpdateTemplate` branch alongside `saveRestTimeChanges()`
2. `saveWeightRepsChanges()` is NOT called when `shouldUpdateTemplate === true`
3. The `updateTemplateExerciseSetValues` import exists
4. `setCachedTemplates` is imported from cache
5. The dependency array of `saveWorkoutAndCleanup` includes `getWeightRepsChanges`
  </verify>
  <done>
- `saveWeightRepsChanges()` defined in workout.tsx, calling `updateTemplateExerciseSetValues` for each exercise with changed sets
- Wired into `saveWorkoutAndCleanup(false)` alongside `saveRestTimeChanges()`
- Skipped when `shouldUpdateTemplate === true` (modal confirmed path)
- Template cache refreshed after successful silent saves via `getTemplates()` + `setCachedTemplates()`
- No type errors in the project
- Existing rest timer silent save behavior completely unaffected (no lines of `saveRestTimeChanges` modified)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Type check:** `npx tsc --noEmit` passes with zero errors
2. **Lint check:** `npx expo lint` passes (or at least no new errors)
3. **Code review checklist:**
   - `updateTemplateExerciseSetValues` queries `template_exercises` first to get `template_exercise_id`, then updates `template_exercise_sets` by `(template_exercise_id, set_number)`
   - `getWeightRepsChanges` only includes sets where `is_done === true` AND `set_number <= templateSetCount`
   - `getWeightRepsChanges` skips exercises not in `originalTemplateSnapshot`
   - `saveWeightRepsChanges` only runs when `shouldUpdateTemplate === false`
   - Cache refresh happens after successful saves
   - No modification to `saveRestTimeChanges` or `getRestTimeChanges`
   - No modification to `hasTemplateChanges` (still structural-only)
   - No modification to the template update confirmation modal logic
</verification>

<success_criteria>
1. Type-safe compilation with zero new errors
2. Three files modified, no other files touched
3. Silent save wired into the correct branch of saveWorkoutAndCleanup (shouldUpdateTemplate === false only)
4. Template cache refreshed after successful silent saves
5. Existing rest timer silent save completely unaffected
6. No changes to the template update confirmation modal behavior
</success_criteria>

<output>
After completion, create `.planning/phases/11-silent-save-weight-reps/11-01-SUMMARY.md`
</output>
