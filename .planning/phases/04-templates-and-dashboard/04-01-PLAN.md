---
phase: 04-templates-and-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/templates.ts
  - src/lib/cache.ts
  - src/hooks/useTemplates.ts
  - app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "Template service can fetch, create, update, and delete templates via Supabase"
    - "Templates are cached in AsyncStorage for instant dashboard loading"
    - "useTemplates hook provides cache-first template data to consumers"
    - "GestureHandlerRootView wraps the app for swipeable gesture support"
  artifacts:
    - path: "src/services/templates.ts"
      provides: "Template CRUD service (8 methods) ported from web app"
      exports: ["templates"]
    - path: "src/lib/cache.ts"
      provides: "Template cache functions added to existing cache module"
      exports: ["getCachedTemplates", "setCachedTemplates", "clearTemplateCache"]
    - path: "src/hooks/useTemplates.ts"
      provides: "Cache-first template loading hook mirroring useExercises pattern"
      exports: ["useTemplates"]
    - path: "app/_layout.tsx"
      provides: "GestureHandlerRootView wrapper at root level"
      contains: "GestureHandlerRootView"
  key_links:
    - from: "src/hooks/useTemplates.ts"
      to: "src/services/templates.ts"
      via: "templates.getTemplates()"
      pattern: "templates\\.getTemplates"
    - from: "src/hooks/useTemplates.ts"
      to: "src/lib/cache.ts"
      via: "getCachedTemplates/setCachedTemplates"
      pattern: "getCachedTemplates|setCachedTemplates"
    - from: "src/services/templates.ts"
      to: "@/lib/supabase"
      via: "supabase client import"
      pattern: "import.*supabase.*from.*@/lib/supabase"
---

<objective>
Port the template service from the web app and build the data foundation for templates: service, cache, hook, and gesture root view.

Purpose: Every screen in Phase 4 (dashboard and template editor) needs template data. This plan provides the data layer they all consume, plus the GestureHandlerRootView required for swipeable card gestures on the dashboard.

Output: Template CRUD service, cache functions, useTemplates hook, and GestureHandlerRootView in root layout.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-templates-and-dashboard/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port template service from web app</name>
  <files>src/services/templates.ts</files>
  <action>
  Copy the web app's template service from `C:\Users\MarioPC\Apps\exercise_tracker_app\packages\shared\src\services\templates.ts` to `src/services/templates.ts`. This is the same port pattern used for exercises.ts in Phase 3.

  Changes needed (import paths only -- ALL business logic stays identical):
  1. Change `import { supabase } from '../lib/supabase'` to `import { supabase } from '@/lib/supabase'`
  2. Change `import type { ... } from '../types/services'` to `import type { ... } from '@/types/services'`
  3. Change `import type { ... } from '../types/database'` to `import type { ... } from '@/types/database'`

  The file is ~730 lines. Keep everything as-is:
  - Raw interface types (RawExerciseData, RawTemplateExercise, RawTemplate, RawTemplateExerciseSet)
  - transformTemplate() function
  - All 8 service functions: getTemplates, getTemplate, createTemplate, updateTemplate, deleteTemplate, addExerciseToTemplate, removeExerciseFromTemplate, updateTemplateExercise
  - Error handling and rollback logic
  - The exported `templates` service object

  Do NOT modify any business logic, query structure, or error handling. Only import paths change.
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. The file should compile with zero type errors. Verify the exported `templates` object has all 8 methods matching the TemplatesService interface in services.ts.</verify>
  <done>src/services/templates.ts exists with all 8 CRUD methods, compiles cleanly, import paths use @/ alias.</done>
</task>

<task type="auto">
  <name>Task 2: Extend cache, create useTemplates hook, add GestureHandlerRootView</name>
  <files>src/lib/cache.ts, src/hooks/useTemplates.ts, app/_layout.tsx</files>
  <action>
  **Part A: Extend cache.ts with template functions**

  Add to the existing `src/lib/cache.ts` (DO NOT remove existing exercise cache functions):
  1. Import `TemplateWithExercises` from `@/types/database`
  2. Add constant `CACHE_KEY_TEMPLATES = 'ironlift:templates'`
  3. Add `getCachedTemplates(): Promise<TemplateWithExercises[] | null>` -- same pattern as getCachedExercises
  4. Add `setCachedTemplates(templates: TemplateWithExercises[]): Promise<void>` -- same pattern as setCachedExercises
  5. Add `clearTemplateCache(): Promise<void>` -- same pattern as clearExerciseCache

  All cache operations are best-effort: errors are logged via console.error but never thrown (same as existing exercise cache pattern).

  **Part B: Create useTemplates hook**

  Create `src/hooks/useTemplates.ts` mirroring the `useExercises` hook pattern exactly:
  1. Import `useState, useEffect, useCallback` from react
  2. Import `TemplateWithExercises` from `@/types/database`
  3. Import `templates` service from `@/services/templates`
  4. Import `getCachedTemplates, setCachedTemplates` from `@/lib/cache`

  Hook behavior (identical strategy to useExercises):
  1. On mount, try cache first for instant display
  2. Fetch fresh data from Supabase via `templates.getTemplates()`
  3. Update cache with fresh data
  4. If network fails and no cache, show error message "Failed to load templates. Please check your connection."

  Return type: `{ templates: TemplateWithExercises[], isLoading: boolean, error: string | null, refresh: () => Promise<void> }`

  No sorting needed -- the service already returns templates sorted by name.

  **Part C: Add GestureHandlerRootView to root layout**

  Modify `app/_layout.tsx`:
  1. Add import: `import { GestureHandlerRootView } from 'react-native-gesture-handler'`
  2. Wrap the outermost component in RootLayout with `<GestureHandlerRootView style={{ flex: 1 }}>...</GestureHandlerRootView>`
  3. The wrapping order should be: GestureHandlerRootView > ThemeProvider > AuthProvider > RootLayoutNav

  This is REQUIRED for ReanimatedSwipeable to work on template cards in Plan 02. Without this wrapper, swipe gestures silently fail.
  </action>
  <verify>
  1. Run `npx tsc --noEmit` -- zero type errors
  2. Verify cache.ts exports all 6 functions (3 exercise + 3 template)
  3. Verify useTemplates.ts exports the useTemplates function
  4. Verify _layout.tsx imports GestureHandlerRootView and wraps the root
  </verify>
  <done>Cache module has template functions, useTemplates hook exists with cache-first loading, GestureHandlerRootView wraps the app root.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Template service has all 8 methods matching TemplatesService interface
3. Cache module has getCachedTemplates, setCachedTemplates, clearTemplateCache
4. useTemplates hook follows identical pattern to useExercises
5. GestureHandlerRootView is the outermost wrapper in _layout.tsx
</verification>

<success_criteria>
- Template CRUD service compiled and typed against existing TemplatesService interface
- Cache-first useTemplates hook ready for dashboard consumption
- GestureHandlerRootView wrapping the app for gesture support
- Zero new dependencies (all libraries already installed)
</success_criteria>

<output>
After completion, create `.planning/phases/04-templates-and-dashboard/04-01-SUMMARY.md`
</output>
