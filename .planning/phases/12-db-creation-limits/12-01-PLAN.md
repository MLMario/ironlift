---
phase: 12-db-creation-limits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sql/migration_creation_limits.sql
  - docs/error_documentation.md
autonomous: false
user_setup:
  - service: supabase
    why: "Run migration SQL in Supabase SQL Editor"
    dashboard_config:
      - task: "Paste and run the migration SQL"
        location: "Supabase Dashboard -> SQL Editor -> New query"

must_haves:
  truths:
    - "Inserting a 21st template for a user raises LIMIT_EXCEEDED:templates:20 with ERRCODE LIM01"
    - "Inserting a 51st user-created exercise raises LIMIT_EXCEEDED:exercises:50 with ERRCODE LIM02"
    - "Inserting a 26th chart for a user raises LIMIT_EXCEEDED:charts:25 with ERRCODE LIM03"
    - "Inserting a 16th exercise into a template raises LIMIT_EXCEEDED:template_exercises:15 with ERRCODE LIM04"
    - "Inserting a 16th exercise into a workout log raises LIMIT_EXCEEDED:workout_exercises:15 with ERRCODE LIM05"
    - "Inserting an 11th set for a template exercise raises LIMIT_EXCEEDED:template_sets:10 with ERRCODE LIM06"
    - "Inserting an 11th set for a workout log exercise raises LIMIT_EXCEEDED:workout_sets:10 with ERRCODE LIM07"
    - "System exercises (is_system = true) bypass the exercise limit trigger entirely"
    - "Re-running the migration SQL produces no errors (idempotent)"
  artifacts:
    - path: "sql/migration_creation_limits.sql"
      provides: "7 trigger functions + 7 triggers for row count limits"
      contains: "enforce_max_templates"
    - path: "docs/error_documentation.md"
      provides: "Error code reference with test INSERT queries"
      contains: "LIM01"
  key_links:
    - from: "sql/migration_creation_limits.sql"
      to: "templates table"
      via: "BEFORE INSERT trigger"
      pattern: "CREATE TRIGGER trg_enforce_max_templates"
    - from: "sql/migration_creation_limits.sql"
      to: "exercises table"
      via: "BEFORE INSERT trigger with is_system early return"
      pattern: "IF NEW\\.is_system = true THEN"
    - from: "sql/migration_creation_limits.sql"
      to: "workout_log_exercises table"
      via: "BEFORE INSERT trigger"
      pattern: "CREATE TRIGGER trg_enforce_max_workout_exercises"
    - from: "sql/migration_creation_limits.sql"
      to: "workout_log_sets table"
      via: "BEFORE INSERT trigger"
      pattern: "CREATE TRIGGER trg_enforce_max_workout_sets"
---

<objective>
Create the SQL migration and error documentation for database-level row count limits via BEFORE INSERT triggers on 7 tables.

Purpose: Enforce maximum row counts as a database-level safety net, preventing any user from exceeding defined limits regardless of client behavior. This is DB protection only -- no application-layer changes.

Output: Single idempotent SQL migration file with 7 trigger functions (with advisory locks) and 7 triggers, plus an error documentation file with test queries for manual verification.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-db-creation-limits/12-CONTEXT.md
@.planning/phases/12-db-creation-limits/12-RESEARCH.md
@sql/current_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create idempotent SQL migration with 7 trigger functions and 7 triggers</name>
  <files>sql/migration_creation_limits.sql</files>
  <action>
Create a single SQL migration file `sql/migration_creation_limits.sql` containing 7 BEFORE INSERT trigger functions with advisory locks and 7 triggers. Follow the exact patterns from 12-RESEARCH.md.

**Naming convention (Claude's discretion):** `enforce_max_{entity}` for functions, `trg_enforce_max_{entity}` for triggers.

**Advisory locks (Claude's discretion): INCLUDE.** One line per function using `pg_advisory_xact_lock(hashtext('prefix_' || id::text))`. Minimal complexity, provides correctness guarantee.

**File structure:**
1. Header comment block explaining purpose, limits, error codes, and idempotency
2. All 7 function + trigger pairs in this order:

**Per-user triggers (direct user_id column):**

| # | Table | Function | Trigger | Limit | ERRCODE | Lock Key Prefix | Notes |
|---|-------|----------|---------|-------|---------|-----------------|-------|
| 1 | `templates` | `enforce_max_templates` | `trg_enforce_max_templates` | 20 | LIM01 | `templates_` | Count WHERE user_id = NEW.user_id |
| 2 | `exercises` | `enforce_max_user_exercises` | `trg_enforce_max_user_exercises` | 50 | LIM02 | `exercises_` | Early return if NEW.is_system = true. Count WHERE user_id = NEW.user_id AND is_system = false |
| 3 | `user_charts` | `enforce_max_user_charts` | `trg_enforce_max_user_charts` | 25 | LIM03 | `charts_` | Count WHERE user_id = NEW.user_id |

**Per-parent triggers (count scoped to parent FK):**

| # | Table | Function | Trigger | Limit | ERRCODE | Lock Key Prefix | Count WHERE |
|---|-------|----------|---------|-------|---------|-----------------|-------------|
| 4 | `template_exercises` | `enforce_max_template_exercises` | `trg_enforce_max_template_exercises` | 15 | LIM04 | `tmpl_ex_` | template_id = NEW.template_id |
| 5 | `workout_log_exercises` | `enforce_max_workout_exercises` | `trg_enforce_max_workout_exercises` | 15 | LIM05 | `wk_ex_` | workout_log_id = NEW.workout_log_id |
| 6 | `template_exercise_sets` | `enforce_max_template_sets` | `trg_enforce_max_template_sets` | 10 | LIM06 | `tmpl_sets_` | template_exercise_id = NEW.template_exercise_id |
| 7 | `workout_log_sets` | `enforce_max_workout_sets` | `trg_enforce_max_workout_sets` | 10 | LIM07 | `wk_sets_` | workout_log_exercise_id = NEW.workout_log_exercise_id |

**Each function/trigger pair follows this pattern:**
```sql
-- N. Table: {table_name}
-- Limit: {limit} per {scope}
-- Error: LIMIT_EXCEEDED:{entity}:{limit} (ERRCODE: LIMxx)
CREATE OR REPLACE FUNCTION {function_name}()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  current_count integer;
BEGIN
  -- [For exercises only: early return for system exercises]
  -- IF NEW.is_system = true THEN RETURN NEW; END IF;

  PERFORM pg_advisory_xact_lock(hashtext('{prefix}' || NEW.{fk_column}::text));

  SELECT COUNT(*) INTO current_count
  FROM {table_name}
  WHERE {fk_column} = NEW.{fk_column};
  -- [For exercises: add AND is_system = false]

  IF current_count >= {limit} THEN
    RAISE EXCEPTION 'LIMIT_EXCEEDED:{entity}:{limit}'
      USING ERRCODE = 'LIMxx';
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS {trigger_name} ON {table_name};
CREATE TRIGGER {trigger_name}
  BEFORE INSERT ON {table_name}
  FOR EACH ROW
  EXECUTE FUNCTION {function_name}();
```

**CRITICAL anti-patterns to avoid:**
- Do NOT use SECURITY DEFINER on any function
- Do NOT omit WHERE clause from COUNT queries (would count all users)
- Use `>=` not `>` in the comparison (count is BEFORE insert)
- Always end with RETURN NEW after the IF block
- Use correct table names: `workout_log_exercises` (not `workout_exercises`), `workout_log_sets` (not `workout_exercise_sets`), `user_charts` (not `charts`)
- Use `is_system` boolean column (not `source = 'user'`)

**Error message format (locked decision):** `LIMIT_EXCEEDED:{entity}:{max_limit}`
- Entity names: templates, exercises, charts, template_exercises, workout_exercises, template_sets, workout_sets

**Idempotency (locked decision):** Use `CREATE OR REPLACE FUNCTION` for functions and `DROP TRIGGER IF EXISTS` + `CREATE TRIGGER` for triggers.
  </action>
  <verify>
Open `sql/migration_creation_limits.sql` and verify:
1. Contains exactly 7 CREATE OR REPLACE FUNCTION statements
2. Contains exactly 7 DROP TRIGGER IF EXISTS + CREATE TRIGGER pairs
3. Each function includes pg_advisory_xact_lock call
4. exercises function has `IF NEW.is_system = true THEN RETURN NEW; END IF;` early return
5. All comparisons use `>= limit` (not `> limit`)
6. All functions end with `RETURN NEW`
7. Table names are correct: `workout_log_exercises`, `workout_log_sets`, `user_charts`
8. Error messages follow format `LIMIT_EXCEEDED:{entity}:{limit}`
9. Error codes are LIM01 through LIM07
  </verify>
  <done>Single idempotent SQL migration file exists at sql/migration_creation_limits.sql with 7 trigger functions (each with advisory lock) and 7 triggers covering all specified tables and limits</done>
</task>

<task type="auto">
  <name>Task 2: Create error documentation with test queries</name>
  <files>docs/error_documentation.md</files>
  <action>
Create `docs/error_documentation.md` documenting all 7 custom error codes per the locked decision.

**Structure:**
1. Title and purpose header
2. Quick reference table with all 7 error codes
3. Detailed section per error code including:
   - Code (e.g., LIM01)
   - Entity name
   - Limit value
   - Trigger function name
   - Table name
   - Parent/scope column
   - Error message returned (e.g., `LIMIT_EXCEEDED:templates:20`)
4. Section on how errors surface in the Supabase JS client:
   - `error.code` contains the SQLSTATE/ERRCODE (e.g., `'LIM01'`)
   - `error.message` contains the exception message (e.g., `'LIMIT_EXCEEDED:templates:20'`)
   - Reference existing pattern: the codebase already checks `error.code === '23505'` for unique constraint violations in `src/services/exercises.ts`
5. Test INSERT queries section -- one test per limit that can be run in Supabase SQL Editor to verify the trigger works. Each test:
   - Uses a DO $$ block with a declared test_user_id UUID placeholder
   - Inserts rows up to the limit (should succeed)
   - Attempts one more insert (should fail)
   - Catches the specific SQLSTATE and prints SUCCESS
   - Cleans up test data
   - Include a note that the user must replace YOUR_TEST_USER_UUID with an actual user ID
   - For per-parent triggers (template_exercises, workout_log_exercises, template_exercise_sets, workout_log_sets), the test must also create a parent record first and clean up afterward

**Important:** Include a note at the top that these are database-level limits only. Service-layer checks and user-facing error messages are planned for a future milestone.
  </action>
  <verify>
Open `docs/error_documentation.md` and verify:
1. Contains quick reference table with all 7 error codes (LIM01-LIM07)
2. Each code entry includes: code, entity, limit, function name, table, error message
3. Contains Supabase JS client error format documentation
4. Contains 7 test query blocks (one per trigger)
5. Test queries use DO $$ blocks with cleanup
  </verify>
  <done>Error documentation file exists at docs/error_documentation.md with complete code reference table, Supabase client error format guide, and 7 runnable test queries for manual verification</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
SQL migration file with 7 BEFORE INSERT trigger functions (with advisory locks) and 7 triggers enforcing row count limits across templates (20), exercises (50), charts (25), exercises-per-template/workout (15), and sets-per-exercise (10). Plus error documentation with test queries.
  </what-built>
  <how-to-verify>
1. Open `sql/migration_creation_limits.sql` and review the SQL for correctness
2. Copy the entire contents of `sql/migration_creation_limits.sql`
3. Go to Supabase Dashboard -> SQL Editor -> New query
4. Paste the SQL and click "Run"
5. Verify it completes without errors
6. Run it a SECOND time to confirm idempotency (should complete without errors again)
7. Open `docs/error_documentation.md` and pick one test query (e.g., the templates limit test)
8. Replace YOUR_TEST_USER_UUID with your actual user ID (find it in Supabase -> Authentication -> Users)
9. Run the test query in SQL Editor -- should print "SUCCESS: ... limit enforced correctly"
  </how-to-verify>
  <resume-signal>Type "approved" if migration runs cleanly and at least one test passes, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] `sql/migration_creation_limits.sql` exists with 7 functions + 7 triggers
- [ ] `docs/error_documentation.md` exists with 7 error codes + 7 test queries
- [ ] Migration runs without errors in Supabase SQL Editor
- [ ] Migration is idempotent (can be re-run without errors)
- [ ] At least one trigger test query confirms the limit is enforced
</verification>

<success_criteria>
1. All 7 BEFORE INSERT triggers are active on the correct tables in Supabase
2. Each trigger enforces the correct row count limit with the correct error message format
3. System exercises (is_system = true) bypass the exercises limit trigger
4. Advisory locks are included in all 7 trigger functions
5. Migration file is tracked in sql/ and error docs are tracked in docs/
</success_criteria>

<output>
After completion, create `.planning/phases/12-db-creation-limits/12-01-SUMMARY.md`
</output>
