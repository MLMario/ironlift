---
phase: 05-active-workout
plan: 07
type: execute
wave: 1
depends_on: []
files_modified: [src/hooks/useWorkoutState.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Workout screen shows all exercises from the template after async template loading completes"
    - "Crash recovery restores a previously active workout with all data intact after app kill and relaunch"
  artifacts:
    - path: "src/hooks/useWorkoutState.ts"
      provides: "Initialization useEffect that correctly waits for async template/restoredWorkout"
      contains: "isInitialized"
  key_links:
    - from: "app/workout.tsx"
      to: "src/hooks/useWorkoutState.ts"
      via: "useWorkoutState(template, restoredBackup) — template arrives async after mount"
      pattern: "useWorkoutState\\(template"
    - from: "src/hooks/useWorkoutState.ts"
      to: "src/hooks/useWorkoutBackup.ts"
      via: "backup.save() depends on activeWorkout having started_at and exercises"
      pattern: "backup\\.save"
---

<objective>
Fix the race condition in useWorkoutState initialization that prevents exercises from appearing on the workout screen and blocks crash recovery.

Purpose: The initialization useEffect in useWorkoutState has an empty dependency array `[]`, but `template` and `restoredWorkout` are loaded asynchronously from AsyncStorage cache in app/workout.tsx. By the time template data arrives, the useEffect has already fired with `template=undefined` and never re-runs. This single root cause blocks 11 of 12 UAT tests.

Output: A working useWorkoutState hook that initializes correctly when template/restoredWorkout arrive asynchronously, with a guard to prevent re-initialization once the workout is active.
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/useWorkoutState.ts
@app/workout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix useWorkoutState initialization race condition</name>
  <files>src/hooks/useWorkoutState.ts</files>
  <action>
Fix the initialization useEffect (currently at line 110-154) in useWorkoutState.ts:

1. Add a `useRef<boolean>(false)` called `isInitialized` to track whether the workout has already been initialized. This prevents re-initialization if template/restoredWorkout references change after the workout is active.

2. Change the useEffect dependency array from `[]` to `[template, restoredWorkout]` so it re-runs when the async data arrives.

3. Inside the useEffect, add an early return guard: `if (isInitialized.current) return;` — this ensures the effect only initializes once, even though it may fire multiple times as dependencies update.

4. After successfully initializing from either `restoredWorkout` or `template`, set `isInitialized.current = true;` to lock initialization.

5. Keep the existing initialization priority (restoredWorkout takes precedence over template, matching web app behavior).

6. Remove the eslint-disable-next-line comment for react-hooks/exhaustive-deps since the deps will now be correct.

The resulting useEffect should look like:

```typescript
const isInitialized = useRef(false);

useEffect(() => {
  if (isInitialized.current) return;

  if (restoredWorkout) {
    setActiveWorkout(restoredWorkout.activeWorkout);
    setOriginalTemplateSnapshot(restoredWorkout.originalTemplateSnapshot);
    isInitialized.current = true;
    return;
  }

  if (template) {
    // ... existing template initialization logic (lines 118-150, unchanged) ...
    isInitialized.current = true;
  }
}, [template, restoredWorkout]);
```

Add `useRef` to the existing import from 'react' on line 11.

Do NOT modify any other logic in this file. The mutation functions, state declarations, and return value remain unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root — must pass with zero errors.

Verify the fix by reading the modified file and confirming:
- `useRef` is imported from 'react'
- `isInitialized` ref is declared before the useEffect
- useEffect deps include `[template, restoredWorkout]`
- Guard `if (isInitialized.current) return;` is the first line inside the effect
- `isInitialized.current = true;` is set after both the restoredWorkout and template initialization branches
- No eslint-disable comment on the deps line
  </verify>
  <done>
The useEffect dependency array includes template and restoredWorkout, an isInitialized ref guard prevents re-initialization, and TypeScript compilation passes. This resolves both UAT gaps: exercises now appear when template loads asynchronously, and crash recovery works because backup.save() receives valid workout data (started_at is set, exercises array is populated).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. The initialization useEffect in useWorkoutState.ts has `[template, restoredWorkout]` as its dependency array
3. An `isInitialized` ref prevents re-initialization after the first successful init
4. No other files were modified
</verification>

<success_criteria>
- TypeScript compiles without errors
- useWorkoutState initializes correctly when template arrives asynchronously (UAT Test 1 fix)
- Backup save receives valid workout data enabling crash recovery (UAT Test 11 fix)
- No behavioral changes to any mutation functions or return values
</success_criteria>

<output>
After completion, create `.planning/phases/05-active-workout/05-07-SUMMARY.md`
</output>
