---
phase: 05-active-workout
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useWorkoutState.ts
  - src/hooks/useRestTimer.ts
  - src/hooks/useWorkoutBackup.ts
autonomous: true

must_haves:
  truths:
    - "Workout state hook manages exercises, sets, and all mutations from a single interface"
    - "Rest timer uses wall-clock time and fires haptic + notification on completion"
    - "Crash recovery backup saves to AsyncStorage on meaningful actions only"
  artifacts:
    - path: "src/hooks/useWorkoutState.ts"
      provides: "All workout state + mutation functions"
      exports: ["useWorkoutState"]
      min_lines: 150
    - path: "src/hooks/useRestTimer.ts"
      provides: "Timer state machine with notifications and haptics"
      exports: ["useRestTimer"]
      min_lines: 100
    - path: "src/hooks/useWorkoutBackup.ts"
      provides: "AsyncStorage backup/restore for crash recovery"
      exports: ["useWorkoutBackup"]
      min_lines: 60
  key_links:
    - from: "src/hooks/useWorkoutState.ts"
      to: "src/types/database.ts"
      via: "TemplateWithExercises type for initialization"
      pattern: "TemplateWithExercises"
    - from: "src/hooks/useRestTimer.ts"
      to: "expo-notifications"
      via: "scheduleNotificationAsync on start, cancelScheduledNotificationAsync on stop"
      pattern: "scheduleNotificationAsync|cancelScheduledNotificationAsync"
    - from: "src/hooks/useWorkoutBackup.ts"
      to: "AsyncStorage"
      via: "getItem/setItem/removeItem for backup data"
      pattern: "AsyncStorage\\.(getItem|setItem|removeItem)"
---

<objective>
Create the three core hooks that power the active workout: useWorkoutState (all workout mutations), useRestTimer (timer state machine with notifications/haptics), and useWorkoutBackup (crash recovery via AsyncStorage).

Purpose: These hooks encapsulate all workout business logic, keeping the workout screen purely presentational. They are direct ports of the web app's patterns adapted for React Native async APIs.
Output: Three hook files in src/hooks/ that compose into the workout screen
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-active-workout/05-CONTEXT.md
@.planning/phases/05-active-workout/05-RESEARCH.md
@src/types/database.ts
@src/types/services.ts
@src/hooks/useTemplates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useWorkoutState hook</name>
  <files>src/hooks/useWorkoutState.ts</files>
  <action>
    Port the workout state management from the web app's `WorkoutSurface.tsx` into a standalone hook. Reference the web app at `Apps/exercise_tracker_app/apps/web/src/surfaces/workout/WorkoutSurface.tsx` for the exact state shape and mutation handlers.

    Define interfaces (exported for reuse):
    - `WorkoutSet`: `{ set_number: number, weight: number, reps: number, is_done: boolean }`
    - `WorkoutExercise`: `{ exercise_id: string, name: string, category: string, order: number, rest_seconds: number, sets: WorkoutSet[] }`
    - `ActiveWorkout`: `{ template_id: string | null, template_name: string, started_at: string | null, exercises: WorkoutExercise[] }`
    - `TemplateSnapshot`: `{ exercises: { exercise_id: string, sets: { set_number: number, weight: number, reps: number }[] }[] }`

    Hook signature: `useWorkoutState(template?: TemplateWithExercises, restoredWorkout?: WorkoutBackupData)`

    State:
    - `activeWorkout: ActiveWorkout` -- initialized from template or restoredWorkout
    - `originalTemplateSnapshot: TemplateSnapshot | null` -- for change detection
    - `revealedSetKey: string | null` -- swipe coordination (one row at a time)

    Initialization (useEffect on mount):
    - If restoredWorkout provided: restore activeWorkout and snapshot from it
    - If template provided: map template.exercises to WorkoutExercise[] with is_done=false on all sets, store deep copy as snapshot
    - Priority: restoredWorkout > template (matching web)

    Mutation functions (all use functional setState for immutability):
    - `updateSetWeight(exerciseIndex, setIndex, weight)` -- update weight value
    - `updateSetReps(exerciseIndex, setIndex, reps)` -- update reps value
    - `toggleSetDone(exerciseIndex, setIndex)` -- toggle is_done, return `{ wasDone: boolean }` so caller can trigger timer
    - `addSet(exerciseIndex)` -- append set copying last set's weight/reps, is_done=false
    - `deleteSet(exerciseIndex, setIndex)` -- remove set (min 1 enforced), renumber remaining, close revealed row
    - `addExercise(exercise: Exercise)` -- append with 3 default sets (weight=0, reps=10, is_done=false), rest_seconds=90, return false if exercise already exists
    - `removeExercise(index)` -- remove by index, return the removed exercise for timer cleanup
    - `setRevealedSet(key: string | null)` -- swipe coordination
    - `closeAllSwipes()` -- set revealedSetKey to null
    - `hasTemplateChanges()` -- structural change detection: compare exercise count, set count per exercise, exercise presence (NOT weight/reps per locked decision)

    Return: `{ activeWorkout, originalTemplateSnapshot, revealedSetKey, ...allMutationFunctions, hasTemplateChanges }`

    IMPORTANT: Do NOT save to AsyncStorage in this hook. Backup is handled by useWorkoutBackup which observes the state externally. This keeps concerns separated.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Hook exports WorkoutSet, WorkoutExercise, ActiveWorkout, TemplateSnapshot interfaces
    - All mutation functions use functional setState (no direct state references in mutations)
  </verify>
  <done>
    - useWorkoutState manages all workout state with immutable updates
    - Template initialization and change detection work correctly
    - Swipe coordination tracks one revealed row at a time
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useRestTimer hook</name>
  <files>src/hooks/useRestTimer.ts</files>
  <action>
    Port the web app's `useTimerState` hook from `Apps/exercise_tracker_app/packages/shared/src/hooks/useTimerState.ts` and extend it with expo-notifications, expo-haptics, and expo-audio for native platform integration.

    Timer state (discriminated union, matching web):
    ```typescript
    type TimerState =
      | { status: 'idle' }
      | { status: 'active'; exerciseIndex: number; startedAt: number; duration: number; remaining: number }
    ```

    CRITICAL DIFFERENCE from web: Use wall-clock time instead of tick counting.
    - Store `startedAt: Date.now()` and `duration` (total seconds)
    - Calculate `remaining = duration - Math.floor((Date.now() - startedAt) / 1000)`
    - setInterval at 1000ms is ONLY for UI updates -- actual time comes from wall clock
    - This avoids timer drift when iOS suspends the app (Pitfall 1 from RESEARCH.md)

    Hook signature: `useRestTimer()`

    Methods:
    - `start(exerciseIndex: number, totalSeconds: number)`:
      1. Stop any existing timer (clear interval, cancel notification)
      2. Set state to active with startedAt=Date.now(), duration=totalSeconds, remaining=totalSeconds
      3. Schedule notification: `Notifications.scheduleNotificationAsync({ content: { title: 'Rest Timer Complete', body: 'Time to start your next set', sound: true }, trigger: { type: SchedulableTriggerInputTypes.TIME_INTERVAL, seconds: totalSeconds } })` -- store the returned notificationId
      4. Start setInterval(1000ms) that recalculates remaining from wall clock. When remaining <= 0: clear interval, fire haptic (`Haptics.impactAsync(ImpactFeedbackStyle.Medium)`), play alert sound (try/catch -- gracefully handle missing asset), cancel the notification (it already fired or is about to), set state to idle
    - `stop()`: clear interval, cancel scheduled notification, set state to idle
    - `adjust(deltaSeconds: number)`: if active, adjust duration by delta (min 0). Cancel old notification, schedule new one with updated remaining time. Recalculate remaining.
    - `isActiveForExercise(exerciseIndex: number)`: boolean check
    - `getProgress(exerciseIndex: number)`: returns 0-100 percentage (remaining/duration * 100), or 100 if idle

    For the alert sound:
    - Try to use `useAudioPlayer` from expo-audio with `require('../../assets/sounds/timer-complete.mp3')`
    - Wrap in try/catch -- if asset doesn't exist, skip sound playback silently
    - The sound is secondary to haptic feedback (haptic is the primary feedback)

    Store intervalRef and notificationIdRef as useRef values. Clean up both on unmount.

    Return: `{ timer, start, stop, adjust, isActiveForExercise, getProgress }`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Hook exports useRestTimer
    - Timer state is a proper discriminated union (idle | active)
    - Wall-clock time pattern used (startedAt + duration, not tick counting)
  </verify>
  <done>
    - Rest timer uses wall-clock time (immune to iOS background suspension)
    - Haptic feedback fires on foreground completion
    - Local notification scheduled on timer start, cancelled on stop/adjust
    - Single timer enforced (starting new replaces previous)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useWorkoutBackup hook</name>
  <files>src/hooks/useWorkoutBackup.ts</files>
  <action>
    Port the web app's `useWorkoutBackup` from `Apps/exercise_tracker_app/packages/shared/src/hooks/useWorkoutBackup.ts`, adapting localStorage (sync) to AsyncStorage (async).

    Define exported interface:
    ```typescript
    interface WorkoutBackupData {
      activeWorkout: ActiveWorkout;
      originalTemplateSnapshot: TemplateSnapshot | null;
      last_saved_at: string;
    }
    ```
    Import ActiveWorkout and TemplateSnapshot from useWorkoutState.

    Hook signature: `useWorkoutBackup(userId: string | undefined)`

    Methods:
    - `save(activeWorkout, snapshot)`: async. Build WorkoutBackupData with last_saved_at=new Date().toISOString(). Guard: skip if no userId, no started_at, or no exercises. Key: `activeWorkout_${userId}`. Use `await AsyncStorage.setItem(key, JSON.stringify(data))`. Wrap in try/catch, log errors but never throw (Pitfall 2 from RESEARCH.md).
    - `clear()`: async. Remove the key. Wrap in try/catch.
    - `restore()`: async. Read and parse the key. Return WorkoutBackupData or null. Wrap in try/catch, return null on error.
    - `getStorageKey()`: return `activeWorkout_${userId}` or null if no userId.

    IMPORTANT per locked decision: This hook does NOT auto-save. The workout screen will call `save()` explicitly on:
    - Set done toggle (checkbox toggled)
    - Exercise add/remove
    - Set add/remove
    NOT on every weight/reps keystroke.

    Return: `{ save, clear, restore, getStorageKey }`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Hook exports useWorkoutBackup and WorkoutBackupData interface
    - All AsyncStorage operations are awaited and wrapped in try/catch
    - No auto-save logic in the hook itself
  </verify>
  <done>
    - Backup save/clear/restore operations work with AsyncStorage
    - Key format is activeWorkout_{userId}
    - Errors are logged but never thrown
    - WorkoutBackupData type exported for use by workout screen and ResumeWorkoutModal
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- all three hooks type-check
- Each hook has clear input/output contract
- No circular dependencies between hooks
- Timer uses wall-clock time, not tick counting
- Backup does not auto-save (explicit save calls only)
</verification>

<success_criteria>
- useWorkoutState manages all workout mutations immutably
- useRestTimer fires haptic + notification + sound on completion
- useWorkoutBackup provides async backup/restore for crash recovery
- All hooks are testable in isolation (no cross-hook dependencies)
</success_criteria>

<output>
After completion, create `.planning/phases/05-active-workout/05-02-SUMMARY.md`
</output>
