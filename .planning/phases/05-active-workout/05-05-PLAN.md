---
phase: 05-active-workout
plan: 05
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-04"]
files_modified:
  - app/workout.tsx
autonomous: true

must_haves:
  truths:
    - "User can see all exercises from template with weight/reps inputs and done checkboxes"
    - "Completing a set triggers the rest timer with inline countdown"
    - "User can add/remove sets and add/remove exercises mid-workout"
    - "Tapping Finish shows confirmation modal, detects template changes, saves workout"
    - "Tapping Cancel shows confirmation modal, discards all progress"
    - "Workout screen disables swipe-back gesture"
  artifacts:
    - path: "app/workout.tsx"
      provides: "Full active workout screen"
      min_lines: 200
  key_links:
    - from: "app/workout.tsx"
      to: "src/hooks/useWorkoutState.ts"
      via: "All workout state and mutations"
      pattern: "useWorkoutState"
    - from: "app/workout.tsx"
      to: "src/hooks/useRestTimer.ts"
      via: "Timer start/stop/adjust on set completion"
      pattern: "useRestTimer"
    - from: "app/workout.tsx"
      to: "src/hooks/useWorkoutBackup.ts"
      via: "Backup save on meaningful actions"
      pattern: "useWorkoutBackup"
    - from: "app/workout.tsx"
      to: "src/services/logging.ts"
      via: "createWorkoutLog on finish"
      pattern: "logging\\.createWorkoutLog"
    - from: "app/workout.tsx"
      to: "src/services/writeQueue.ts"
      via: "enqueue for offline save"
      pattern: "enqueue"
    - from: "app/workout.tsx"
      to: "src/components/WorkoutExerciseCard.tsx"
      via: "Exercise card rendering"
      pattern: "WorkoutExerciseCard"
    - from: "app/workout.tsx"
      to: "src/components/ConfirmationModal.tsx"
      via: "Finish, cancel, and template update modals"
      pattern: "ConfirmationModal"
---

<objective>
Replace the workout.tsx placeholder with the full active workout screen. Wire all hooks (useWorkoutState, useRestTimer, useWorkoutBackup) to all components (WorkoutExerciseCard, ConfirmationModal, ExercisePickerModal). Implement finish flow (save + template change detection), cancel flow (discard), and offline save via write queue.

Purpose: This is the screen assembly -- connecting all the independently-built hooks and components into the complete workout experience. It's the final wiring step before dashboard integration.
Output: Complete workout.tsx screen replacing the Phase 1 placeholder
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-active-workout/05-CONTEXT.md
@.planning/phases/05-active-workout/05-RESEARCH.md
@app/workout.tsx
@app/_layout.tsx
@src/hooks/useWorkoutState.ts
@src/hooks/useRestTimer.ts
@src/hooks/useWorkoutBackup.ts
@src/services/logging.ts
@src/services/writeQueue.ts
@src/components/WorkoutExerciseCard.tsx
@src/components/ConfirmationModal.tsx
@src/components/ExercisePickerModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build workout screen with exercise list and header</name>
  <files>app/workout.tsx</files>
  <action>
    Replace the entire workout.tsx placeholder with the full active workout screen.

    **Route params:** The workout screen receives template data via route params (Expo Router `useLocalSearchParams`). The dashboard will pass the template ID, and the workout screen loads the template from cache or service. Alternatively, use a simpler approach: pass `templateId` as a search param, then look it up from the cached templates. For restored workouts (crash recovery), pass `restore=true` param.

    Actually, the cleanest approach for Expo Router: pass `templateId` as query param. The workout screen:
    1. Reads `templateId` from `useLocalSearchParams()`
    2. Also reads `restore` param (string "true" if resuming from backup)
    3. If restore=true: load backup data from useWorkoutBackup.restore(), pass to useWorkoutState
    4. If templateId: find template from cached templates (getCachedTemplates from cache.ts), pass to useWorkoutState
    5. If neither: show error and navigate back

    **Screen structure:**

    Header (iOS nav bar style per locked decision):
    - SafeAreaView at top
    - Horizontal row: Cancel button (left) | Template name (center, numberOfLines=1) | Finish button (right)
    - Cancel: Pressable with "Cancel" text, textSecondary color
    - Title: textPrimary, semibold, centered, flex:1
    - Finish: Pressable with "Finish" text, accent color, semibold
    - Header has bgPrimary background with bottom border

    Body:
    - `KeyboardAvoidingView` with `behavior="padding"` and `keyboardVerticalOffset` appropriate for header height
    - `ScrollView` with `keyboardShouldPersistTaps="handled"` (per RESEARCH.md Pitfall 4)
    - Map activeWorkout.exercises to WorkoutExerciseCard components
    - "Add Exercise" button at bottom: accent background, full width, 44px min height, "Add Exercise" text

    **Hook wiring:**

    ```typescript
    const { activeWorkout, originalTemplateSnapshot, revealedSetKey,
            updateSetWeight, updateSetReps, toggleSetDone,
            addSet, deleteSet, addExercise, removeExercise,
            setRevealedSet, closeAllSwipes, hasTemplateChanges } = useWorkoutState(template, restoredBackup);

    const { timer, start: startTimer, stop: stopTimer, adjust: adjustTimer,
            isActiveForExercise, getProgress } = useRestTimer();

    const backup = useWorkoutBackup(userId);
    ```

    **Set done handler** (connects state + timer + backup):
    ```typescript
    function handleToggleDone(exerciseIndex: number, setIndex: number) {
      const result = toggleSetDone(exerciseIndex, setIndex);
      if (!result.wasDone) {
        // Was not done, now is done -> start timer
        const exercise = activeWorkout.exercises[exerciseIndex];
        startTimer(exerciseIndex, exercise.rest_seconds);
      }
      // Save backup on set done toggle (per locked decision)
      backup.save(activeWorkout, originalTemplateSnapshot);
    }
    ```

    **Backup save triggers** (per locked decision -- NOT on every keystroke):
    - After toggleSetDone
    - After addSet (then save)
    - After deleteSet (then save)
    - After addExercise (then save)
    - After removeExercise (then save)
    Note: Weight/reps changes do NOT trigger backup saves.

    For backup saves, since hooks update state asynchronously, use a `useEffect` approach:
    Create a `backupTrigger` counter state. Increment it on meaningful actions. useEffect watches backupTrigger and calls backup.save(activeWorkout, snapshot).

    **Remove exercise handler** (connects state + timer):
    ```typescript
    function handleRemoveExercise(exerciseIndex: number) {
      // Stop timer if removing exercise that has active timer
      if (isActiveForExercise(exerciseIndex)) {
        stopTimer();
      }
      removeExercise(exerciseIndex);
    }
    ```

    **Exercise picker:**
    - "Add Exercise" button opens ExercisePickerModal (Phase 3 component, already built)
    - On select: call addExercise(exercise), close modal
    - excludeIds: activeWorkout.exercises.map(ex => ex.exercise_id)

    **Keyboard dismissal:**
    - Import `Keyboard` from react-native
    - Call `Keyboard.dismiss()` when tapping Cancel, Finish, or the ScrollView background
    - `keyboardShouldPersistTaps="handled"` ensures buttons work without first dismissing keyboard
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - workout.tsx imports and uses useWorkoutState, useRestTimer, useWorkoutBackup
    - workout.tsx renders WorkoutExerciseCard for each exercise
    - Header has Cancel/Title/Finish layout
    - KeyboardAvoidingView and keyboardShouldPersistTaps configured
  </verify>
  <done>
    - Workout screen displays all exercises from template with full editing capability
    - Set done toggles trigger timer and backup save
    - Exercise add/remove works via picker modal
    - Keyboard handling prevents common iOS issues
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire finish flow, cancel flow, and offline save</name>
  <files>app/workout.tsx</files>
  <action>
    Add the finish/cancel/template-update modals and save logic to the workout screen built in Task 1. This is in the SAME file (app/workout.tsx) -- extending it with modal state and save handlers.

    **Modal state:**
    ```typescript
    const [showFinishModal, setShowFinishModal] = useState(false);
    const [showCancelModal, setShowCancelModal] = useState(false);
    const [showTemplateUpdateModal, setShowTemplateUpdateModal] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    ```

    **Finish flow** (per locked decision):
    1. Tap Finish -> validate activeWorkout.exercises.length > 0 (if empty, show Alert.alert error)
    2. Show ConfirmationModal: title="Finish Workout?", message="Save this workout and end your session?", confirmLabel="Save", cancelLabel="Cancel", confirmVariant="primary"
    3. On confirm: check hasTemplateChanges()
       - If changes detected AND template_id exists: show template update modal
       - If no changes: call saveWorkoutAndCleanup()
    4. Template update modal: ConfirmationModal with title="Update Template?", message="You made changes during this workout. Update the template with these changes?", secondaryMessage="This will update the exercise list and number of sets in your template.", confirmLabel="Yes, Update", cancelLabel="No, Keep Original", confirmVariant="primary", dismissOnOverlayPress=false (per locked decision)
       - On confirm (Yes, Update): call templates.updateTemplate with current exercises, then saveWorkoutAndCleanup()
       - On cancel (No, Keep Original): call saveWorkoutAndCleanup() without updating template

    **saveWorkoutAndCleanup():**
    ```typescript
    async function saveWorkoutAndCleanup() {
      setIsSaving(true);
      try {
        const workoutData: WorkoutLogInput = {
          template_id: activeWorkout.template_id,
          started_at: activeWorkout.started_at!,
          exercises: activeWorkout.exercises.map((ex, i) => ({
            exercise_id: ex.exercise_id,
            rest_seconds: ex.rest_seconds,
            order: i,
            sets: ex.sets.map(s => ({
              set_number: s.set_number,
              weight: s.weight || 0,
              reps: s.reps || 0,
              is_done: s.is_done,
            })),
          })),
        };

        // Try online save first
        const { error } = await logging.createWorkoutLog(workoutData);

        if (error) {
          // Online save failed -- enqueue for offline sync
          await enqueue({
            id: crypto.randomUUID(),
            type: 'workout_log',
            payload: workoutData,
            created_at: new Date().toISOString(),
          });
        }

        // Always: stop timer, clear backup, navigate to dashboard
        stopTimer();
        await backup.clear();
        router.back(); // Navigate to dashboard
      } catch (err) {
        // Even on unexpected error, enqueue and navigate
        // The write queue will retry later
        await enqueue({
          id: crypto.randomUUID(),
          type: 'workout_log',
          payload: workoutData,
          created_at: new Date().toISOString(),
        });
        stopTimer();
        await backup.clear();
        router.back();
      } finally {
        setIsSaving(false);
      }
    }
    ```

    **Cancel flow** (per locked decision):
    1. Tap Cancel -> show ConfirmationModal: title="Cancel Workout?", message="All progress will be lost.", confirmLabel="Discard", cancelLabel="Go Back", confirmVariant="danger"
    2. On confirm: stop timer, clear backup, navigate to dashboard (router.back())
    3. Discard all -- no "save as incomplete" option

    **Template update during offline** (per research recommendation):
    - If updateTemplate fails (offline), skip it silently -- the workout log is the priority
    - Template update is best-effort, workout save is guaranteed (via write queue)

    **Render the modals:**
    Add three ConfirmationModal instances at the bottom of the JSX (inside the root View, after ScrollView):
    - Finish modal
    - Cancel modal
    - Template update modal (with dismissOnOverlayPress=false)

    **Loading state during save:**
    - When isSaving=true, disable Finish button (or show ActivityIndicator)
    - Prevent double-tap on Finish
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Three ConfirmationModal instances rendered
    - Finish flow: validate -> confirm -> template check -> save/enqueue -> navigate
    - Cancel flow: confirm -> stop timer -> clear backup -> navigate
    - Template update modal has dismissOnOverlayPress=false
    - Offline save uses write queue enqueue as fallback
  </verify>
  <done>
    - Complete finish flow with template change detection and save
    - Complete cancel flow with discard and cleanup
    - Offline save falls back to write queue automatically
    - Template update modal is non-dismissible by overlay tap
    - All modals use ConfirmationModal component consistently
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- workout.tsx type-checks completely
- Workout screen is navigable (can be pushed from dashboard)
- Finish saves to database or write queue
- Cancel discards all state
- Template change detection works (structural only, not weight/reps)
- Backup saves only on meaningful actions
</verification>

<success_criteria>
- WORK-01 through WORK-09: Exercise display, set editing, add/remove
- WORK-10, WORK-11, WORK-13: Rest timer inline with adjust and auto-cancel
- WORK-14: Finish saves to database
- WORK-15: Template change detection and update prompt
- WORK-16: Cancel with confirmation
- WORK-17: Stack push with swipe-back disabled
- WORK-18: Auto-save to AsyncStorage on meaningful actions
- WORK-20: Offline save via write queue
</success_criteria>

<output>
After completion, create `.planning/phases/05-active-workout/05-05-SUMMARY.md`
</output>
