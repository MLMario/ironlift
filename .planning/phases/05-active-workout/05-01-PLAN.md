---
phase: 05-active-workout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/logging.ts
  - src/services/writeQueue.ts
  - src/hooks/useWriteQueue.ts
  - app/_layout.tsx
  - assets/sounds/timer-complete.mp3
autonomous: true

must_haves:
  truths:
    - "Logging service can create workout logs with nested exercises and sets"
    - "Write queue can enqueue offline workout saves and process them when online"
    - "Notification permissions are requested at app startup"
  artifacts:
    - path: "src/services/logging.ts"
      provides: "Workout logging CRUD (port from web)"
      exports: ["logging"]
    - path: "src/services/writeQueue.ts"
      provides: "Offline write queue with idempotency"
      exports: ["enqueue", "processQueue", "getQueue", "clearQueue"]
    - path: "src/hooks/useWriteQueue.ts"
      provides: "Auto-sync hook (AppState + NetInfo triggers)"
      exports: ["useWriteQueue"]
  key_links:
    - from: "src/services/logging.ts"
      to: "src/lib/supabase.ts"
      via: "Supabase client import"
      pattern: "import.*supabase.*from.*@/lib/supabase"
    - from: "src/services/writeQueue.ts"
      to: "src/services/logging.ts"
      via: "logging.createWorkoutLog for queue processing"
      pattern: "logging\\.createWorkoutLog"
---

<objective>
Install Phase 5 dependencies, port the logging service from the web app, create the offline write queue service, configure notification permissions, and bundle the timer alert sound asset.

Purpose: Establish all non-UI infrastructure that the workout hooks and screen will consume. This is the data layer and platform integration layer.
Output: logging.ts (service), writeQueue.ts (service), useWriteQueue.ts (hook), notification config in _layout.tsx, timer-complete.mp3 asset
</objective>

<execution_context>
@C:\Users\MarioPC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\MarioPC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-active-workout/05-CONTEXT.md
@.planning/phases/05-active-workout/05-RESEARCH.md
@src/lib/supabase.ts
@src/lib/cache.ts
@src/types/database.ts
@src/types/services.ts
@src/services/templates.ts
@app/_layout.tsx
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and port logging service</name>
  <files>
    package.json
    src/services/logging.ts
  </files>
  <action>
    1. Install Phase 5 dependencies:
       ```bash
       npx expo install expo-notifications react-native-svg expo-audio @react-native-community/netinfo
       ```

    2. Port `logging.ts` from web app at `Apps/exercise_tracker_app/packages/shared/src/services/logging.ts`.
       - Change import: `import { supabase } from '../lib/supabase'` -> `import { supabase } from '@/lib/supabase'`
       - Change type imports to use `@/types/services` and `@/types/database` paths
       - Keep ALL function implementations identical to web -- `createWorkoutLog`, `getWorkoutLogs`, `getWorkoutLog`, `getExerciseHistory`, `getExerciseMetrics`, `getRecentExerciseData`, `getWorkoutLogsPaginated`, `getWorkoutSummaryStats`
       - Keep the `calculateMetrics` internal helper
       - Export the `logging` object implementing `LoggingService` interface
       - This is a direct port with zero logic changes, only import path swaps (same pattern as exercises.ts and templates.ts from prior phases)
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no errors in logging.ts
    - logging.ts exports a `logging` object with all LoggingService methods
    - All 4 new packages appear in package.json dependencies
  </verify>
  <done>
    - logging.ts is a working port of the web app's logging service with correct import paths
    - expo-notifications, react-native-svg, expo-audio, @react-native-community/netinfo installed
  </done>
</task>

<task type="auto">
  <name>Task 2: Create write queue service and sync hook</name>
  <files>
    src/services/writeQueue.ts
    src/hooks/useWriteQueue.ts
  </files>
  <action>
    1. Create `src/services/writeQueue.ts`:
       - Import AsyncStorage and NetInfo
       - Define `WriteQueueEntry` interface: `{ id: string, type: 'workout_log', payload: WorkoutLogInput, created_at: string, attempts: number, last_attempt_at: string | null }`
       - AsyncStorage key: `ironlift:writeQueue` (single queue, not per-user, per research recommendation)
       - `getQueue()`: read and parse queue from AsyncStorage, return empty array on error
       - `enqueue(entry)`: add entry to queue with attempts=0, last_attempt_at=null
       - `processQueue()`: check NetInfo.fetch() for connectivity, iterate queue entries, call logging.createWorkoutLog for each, keep failed entries with incremented attempt count and updated last_attempt_at. Implement exponential backoff check: skip entries where `Date.now() - last_attempt_at < backoff(attempts)`. Backoff: 5s, 15s, 45s, 135s, cap at 5min (300s). Max 10 attempts.
       - `clearQueue()`: remove the key from AsyncStorage
       - All operations are async, errors logged but never thrown (best-effort, matching cache pattern)

    2. Create `src/hooks/useWriteQueue.ts`:
       - Import AppState from react-native, NetInfo from @react-native-community/netinfo
       - Import processQueue from writeQueue service
       - On mount: subscribe to AppState changes (process queue when state becomes 'active')
       - On mount: subscribe to NetInfo connectivity changes (process queue when isConnected becomes true)
       - Cleanup both subscriptions on unmount
       - Export `useWriteQueue()` hook (no return value needed -- it's a side-effect-only hook)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - writeQueue.ts exports enqueue, processQueue, getQueue, clearQueue
    - useWriteQueue.ts exports useWriteQueue hook
  </verify>
  <done>
    - Write queue service can enqueue workout logs and process them with exponential backoff
    - Sync hook auto-processes queue on app foreground and connectivity changes
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure notifications and bundle alert sound</name>
  <files>
    app/_layout.tsx
    assets/sounds/timer-complete.mp3
  </files>
  <action>
    1. Add notification handler configuration to `app/_layout.tsx`:
       - Import `* as Notifications from 'expo-notifications'` at the top of the file
       - Call `Notifications.setNotificationHandler({ handleNotification: async () => ({ shouldShowAlert: true, shouldPlaySound: true, shouldSetBadge: false }) })` at module level (outside any component, after imports), following the exact pattern from Expo docs
       - Add `Notifications.requestPermissionsAsync()` call inside the `RootLayoutNav` component's existing `useEffect` that hides the splash screen (after `SplashScreen.hideAsync()`). This requests permission once after auth state resolves. Do NOT await it -- fire and forget, permission denial is handled gracefully (foreground haptic + sound still works)

    2. Add `useWriteQueue()` call inside `RootLayoutNav` component (after auth check, only when logged in):
       - Import useWriteQueue from '@/hooks/useWriteQueue'
       - Call `useWriteQueue()` unconditionally inside RootLayoutNav -- the hook itself should be safe to call regardless of auth state (it just processes the queue)

    3. Create a placeholder alert sound file:
       - Create `assets/sounds/` directory
       - Create a minimal valid MP3 file at `assets/sounds/timer-complete.mp3`. Since we cannot generate audio, create a placeholder by writing a comment file explaining this needs a real MP3 asset. Alternatively, use a simple approach: find and copy any short audio file, or create `assets/sounds/.gitkeep` and document that a real timer-complete.mp3 must be placed here. The RESEARCH.md noted this as LOW confidence and recommended including a placeholder.
       - For now, create the directory with a `.gitkeep` file and add a note in the code that the sound asset path is `require('../../assets/sounds/timer-complete.mp3')` -- the useRestTimer hook (Plan 02) will handle the case where the asset fails to load gracefully.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - _layout.tsx imports and configures expo-notifications
    - _layout.tsx calls useWriteQueue()
    - assets/sounds/ directory exists
  </verify>
  <done>
    - Notification handler configured for foreground display
    - Permission requested at app startup (after auth resolves)
    - Write queue auto-sync active for logged-in users
    - Sound asset directory ready (placeholder until real MP3 sourced)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` -- full project type-checks with new files
- `npx expo start` -- app launches without errors (notification permission prompt may appear)
- All new service files follow the established pattern (supabase import, ServiceResult return type, error handling)
</verification>

<success_criteria>
- Logging service ported with all methods matching web app
- Write queue service operational with enqueue/process/backoff
- Notification permissions requested at startup
- Write queue auto-syncs on foreground and connectivity
- All dependencies installed and type-checking
</success_criteria>

<output>
After completion, create `.planning/phases/05-active-workout/05-01-SUMMARY.md`
</output>
